/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import java.io.EOFException;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Stack;

import org.apache.xerces.impl.XMLEntityManager;
import org.apache.xerces.impl.XMLEntityScanner;
import org.apache.xerces.impl.XMLErrorReporter;
import org.apache.xerces.impl.msg.XMLMessageFormatter;
import org.apache.xerces.util.XMLStringBuffer;
import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.XMLChar;
import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLAttributes;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLDocumentHandler;
import org.apache.xerces.xni.XMLDocumentSource;
import org.apache.xerces.xni.XMLEntityHandler;
import org.apache.xerces.xni.XMLString;

import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.helpers.NamespaceSupport;

/**
 * This class is responsible for scanning XML document structure
 * and content. The scanner acts as the source for the document
 * information which is communicated to the document handler.
 * <p>
 * This component requires the following features and properties from the
 * component manager that uses it:
 * <ul>
 *  <li>http://xml.org/sax/features/namespaces</li>
 *  <li>http://apache.org/xml/properties/internal/symbol-table</li>
 *  <li>http://apache.org/xml/properties/internal/error-reporter</li>
 *  <li>http://apache.org/xml/properties/internal/entity-manager</li>
 * </ul>
 *
 * @author Stubs generated by DesignDoc on Mon Sep 11 11:10:57 PDT 2000
 * @author Andy Clark, IBM
 *
 * @version $Id$
 */
public class XMLDocumentScanner
    implements XMLComponent, XMLDocumentSource, XMLEntityHandler {

    //
    // Constants
    //

    // sax features

    /** SAX feature prefix. */
    protected static final String SAX_FEATURE_PREFIX = "http://xml.org/sax/features/";

    /** Namespaces feature. */
    protected static final String NAMESPACES_FEATURE = "namespaces";

    // xerces properties

    /** Xerces property prefix. */
    protected static final String XERCES_PROPERTY_PREFIX = "http://apache.org/xml/properties/";

    /** Symbol table property. */
    protected static final String SYMBOL_TABLE_PROPERTY = "internal/symbol-table";
    
    /** Error reporter property. */
    protected static final String ERROR_REPORTER_PROPERTY = "internal/error-reporter";

    /** Entity manager property. */
    protected static final String ENTITY_MANAGER_PROPERTY = "internal/entity-manager";

    // scanner states

    /** Scanner state: XML declaration. */
    protected static final int SCANNER_STATE_XML_DECL = 0;

    /** Scanner state: start of markup. */
    protected static final int SCANNER_STATE_START_OF_MARKUP = 1;

    /** Scanner state: comment. */
    protected static final int SCANNER_STATE_COMMENT = 2;

    /** Scanner state: processing instruction. */
    protected static final int SCANNER_STATE_PI = 3;

    /** Scanner state: DOCTYPE. */
    protected static final int SCANNER_STATE_DOCTYPE = 4;

    /** Scanner state: prolog. */
    protected static final int SCANNER_STATE_PROLOG = 5;

    /** Scanner state: root element. */
    protected static final int SCANNER_STATE_ROOT_ELEMENT = 6;

    /** Scanner state: content. */
    protected static final int SCANNER_STATE_CONTENT = 7;

    /** Scanner state: reference. */
    protected static final int SCANNER_STATE_REFERENCE = 8;

    /** Scanner state: attribute list. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_LIST = 9;

    /** Scanner state: attribute name. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_NAME = 10;

    /** Scanner state: attribute value. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_VALUE = 11;

    /** Scanner state: trailing misc. */
    protected static final int SCANNER_STATE_TRAILING_MISC = 12;

    /** Scanner state: end of input. */
    protected static final int SCANNER_STATE_END_OF_INPUT = 13;

    /** Scanner state: terminated. */
    protected static final int SCANNER_STATE_TERMINATED = 14;

    /** Scanner state: CDATA section. */
    protected static final int SCANNER_STATE_CDATA = 15;

    // debugging

    /** Debug scanner state. */
    private static final boolean DEBUG_SCANNER_STATE = false;

    /** Debug dispatcher. */
    private static final boolean DEBUG_DISPATCHER = false;

    /** Debug content dispatcher scanning. */
    private static final boolean DEBUG_CONTENT_SCANNING = false;

    //
    // Data
    //

    // properties

    /** Symbol table. */
    protected SymbolTable fSymbolTable;

    /** Error reporter. */
    protected XMLErrorReporter fErrorReporter;

    /** Entity manager. */
    protected XMLEntityManager fEntityManager;

    /** DTD scanner. */
    /*** REVISIT: Add DTD support. ***
    protected XMLDTDScanner fDTDScanner;
    /***/

    // protected data

    /** Document handler. */
    protected XMLDocumentHandler fDocumentHandler;

    /** Entity scanner. */
    protected XMLEntityScanner fEntityScanner;

    /** Entity stack. */
    protected Stack fEntityStack = new Stack();

    /** Scanner state. */
    protected int fScannerState;

    /** Seen doctype declaration. */
    protected boolean fSeenDoctypeDecl;
    
    /** Standalone. */
    protected boolean fStandalone;

    /** Scanning attribute. */
    protected boolean fScanningAttribute;

    /** Scanning DTD. */
    protected boolean fScanningDTD;

    // element information

    /** Element depth. */
    protected int fElementDepth;

    /** Current element. */
    protected QName fCurrentElement;

    /** Element stack. */
    protected Stack fElementStack = new Stack();

    // namespaces

    /** Namespaces. */
    protected boolean fNamespaces = true;

    /** Namespace support. */
    protected NamespaceSupport fNamespaceSupport = new NamespaceSupport();

    // dispatchers

    /** Active dispatcher. */
    protected Dispatcher fDispatcher;

    /** XML declaration dispatcher. */
    protected Dispatcher fXMLDeclDispatcher = new XMLDeclDispatcher();

    /** Prolog dispatcher. */
    protected Dispatcher fPrologDispatcher = new PrologDispatcher();

    /** Content dispatcher. */
    protected Dispatcher fContentDispatcher = new ContentDispatcher();

    /** Trailing miscellaneous section dispatcher. */
    protected Dispatcher fTrailingMiscDispatcher = new TrailingMiscDispatcher();

    /** End of input dispatcher. */
    protected Dispatcher fEndOfInputDispatcher = new EndOfInputDispatcher();

    // private data

    /** Element QName. */
    private QName fElementQName = new QName();

    /** Attribute QName. */
    private QName fAttributeQName = new QName();

    /** Element attributes. */
    private XMLAttributes fAttributes = new XMLAttributes();

    /** String. */
    private XMLString fString = new XMLString();

    /** String buffer. */
    private XMLStringBuffer fStringBuffer = new XMLStringBuffer();

    /** Single character array. */
    private final char[] fSingleChar = new char[1];

    //
    // Constructors
    //

    /** Default constructor. */
    public XMLDocumentScanner() {
    } // <init>()

    //
    // Public methods
    //

    /** 
     * Scans a document. 
     * <p>
     * <strong>Note:</strong> The caller of this method is responsible
     * for having called <code>reset(XMLComponentManager)</code> before
     * any scanning and having initialized the entity manager by starting 
     * the document entity.
     *
     * @param complete True to completely scan the rest of the document.
     *
     * @returns True if scanning is not finished.
     */
    public boolean scanDocument(boolean complete) 
        throws IOException, SAXException {

        // keep dispatching "events"
        do {
            if (!fDispatcher.dispatch(complete)) {
                return false;
            }
        } while (complete);

        // return success
        return true;

    } // scanDocument(boolean):boolean

    //
    // XMLComponent methods
    //

    /**
     * 
     * 
     * @param componentManager The component manager.
     *
     * @throws SAXException Throws exception if required features and
     *                      properties cannot be found.
     */
    public void reset(XMLComponentManager componentManager)
        throws SAXException {

        // SAX features
        fNamespaces = componentManager.getFeature(SAX_FEATURE_PREFIX + NAMESPACES_FEATURE);
        fAttributes.setNamespaces(fNamespaces);

        // Xerces properties
        fSymbolTable = (SymbolTable)componentManager.getProperty(XERCES_PROPERTY_PREFIX + SYMBOL_TABLE_PROPERTY);
        fErrorReporter = (XMLErrorReporter)componentManager.getProperty(XERCES_PROPERTY_PREFIX + ERROR_REPORTER_PROPERTY);
        fEntityManager = (XMLEntityManager)componentManager.getProperty(XERCES_PROPERTY_PREFIX + ENTITY_MANAGER_PROPERTY);
        /*** REVISIT: Add DTD support. ***
        fDTDScanner = (XMLDTDScanner)componentManager.getProperty(XERCES_PROPERTY_PREFIX + DTD_SCANNER_PROPERTY);
        /***/

        // initialize scanner
        fEntityManager.setEntityHandler(this);
        fEntityScanner = fEntityManager.getEntityScanner();
        
        // initialize vars
        fEntityStack.removeAllElements();
        fNamespaceSupport.reset();

        fElementDepth = 0;
        fCurrentElement = null;
        fElementStack.removeAllElements();
        
        fSeenDoctypeDecl = false;
        fStandalone = false;
        fScanningDTD = false;

        // setup dispatcher
        setScannerState(SCANNER_STATE_XML_DECL);
        setDispatcher(fXMLDeclDispatcher);
        
    } // reset(XMLComponentManager)

    /**
     * Sets the state of a feature during parsing.
     * 
     * @param featureId 
     * @param state 
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        // sax features
        if (featureId.startsWith(SAX_FEATURE_PREFIX)) {
            String feature = featureId.substring(SAX_FEATURE_PREFIX.length());
            if (feature.equals(NAMESPACES_FEATURE)) {
                fNamespaces = state;
                fAttributes.setNamespaces(fNamespaces);
            }
        }

    } // setFeature(String,boolean)

    /**
     * Sets the value of a property during parsing.
     * 
     * @param propertyId 
     * @param value 
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        
        // Xerces properties
        if (propertyId.startsWith(XERCES_PROPERTY_PREFIX)) {
            String property = propertyId.substring(XERCES_PROPERTY_PREFIX.length());
            if (property.equals(SYMBOL_TABLE_PROPERTY)) {
                fSymbolTable = (SymbolTable)value;
            }
            else if (property.equals(ERROR_REPORTER_PROPERTY)) {
                fErrorReporter = (XMLErrorReporter)value;
            }
            else if (property.equals(ENTITY_MANAGER_PROPERTY)) {
                fEntityManager = (XMLEntityManager)value;
            }
            return;
        }

    } // setProperty(String,Object)

    //
    // XMLDocumentSource methods
    //

    /**
     * setDocumentHandler
     * 
     * @param documentHandler 
     */
    public void setDocumentHandler(XMLDocumentHandler documentHandler) {
        fDocumentHandler = documentHandler;
    } // setDocumentHandler(XMLDocumentHandler)

    //
    // XMLEntityHandler methods
    //

    /**
     * startEntity
     * 
     * @param name 
     * @param publicId 
     * @param systemId 
     */
    public void startEntity(String name, String publicId, String systemId,
                            String encoding) throws SAXException {

        // keep track of this entity
        Entity entity = new Entity(name, publicId, systemId, fElementDepth);
        fEntityStack.push(entity);

        // call handler
        if (!fScanningAttribute && fDocumentHandler != null) {
            fDocumentHandler.startEntity(name, publicId, systemId, encoding);
        }

    } // startEntity(String,String,String,String)

    /**
     * endEntity
     * 
     * @param name 
     */
    public void endEntity(String name) throws SAXException {

        // sanity check
        Entity entity = (Entity)fEntityStack.pop();
        if (!name.equals(entity.name)) {
            // REVISIT: report error
            throw new SAXException("internal error: startEntity(\""+entity.name+"\") "+
                                   "doesn't match endEntity(\""+name+"\")");
        }

        // check for un-balanced entity content
        // 1) state isn't set back to SCANNER_STATE_CONTENT
        if (fScannerState != SCANNER_STATE_CONTENT) {
            switch (fScannerState) {
                case SCANNER_STATE_COMMENT: {
                    // REVISIT: report error
                    throw new SAXException("MSG_COMMENT_NOT_IN_ONE_ENTITY");
                }
                case SCANNER_STATE_PI: {
                    // REVISIT: report error
                    throw new SAXException("MSG_PI_NOT_IN_ONE_ENTITY");
                }
                default: {
                    // REVISIT: report error
                    throw new SAXException("at end of entity, state should be CONTENT, not "+fScannerState);
                }
            }
        }

        // 2) scanner markup depth isn't what it was at the start of
        //    the entity
        if (fElementDepth != entity.elementDepth) {
            // REVISIT: report error
            throw new SAXException("entity content not balanced");
        }

        // call handler
        if (!fScanningAttribute && fDocumentHandler != null) {
            fDocumentHandler.endEntity(name);
        }

    } // endEntity(String)

    //
    // Protected methods
    //

    // scanning methods

    /**
     * Scans an XML or text declaration.
     * <p>
     * <pre>
     * [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
     * [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ")
     * [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' |  "'" EncName "'" )
     * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
     * [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'")
     *                 | ('"' ('yes' | 'no') '"'))
     *
     * [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
     * </pre>
     *
     * @param scanningTextDecl True if a text declaration is to
     *                         be scanned instead of an XML
     *                         declaration.
     */
    protected void scanXMLDeclOrTextDecl(boolean scanningTextDecl) 
        throws IOException, SAXException {

        // pseudo-attribute values
        String version = null;
        String encoding = null;
        String actualEncoding = null;
        String standalone = null;

        // scan pseudo-attributes
        final int STATE_VERSION = 0;
        final int STATE_ENCODING = 1;
        final int STATE_STANDALONE = 2;
        final int STATE_DONE = 3;
        int state = STATE_VERSION;
        fEntityScanner.skipSpaces();
        while (fEntityScanner.peekChar() != '?') {
            String name = scanPseudoAttribute(fString);
            switch (state) {
                case STATE_VERSION: {
                    if (name.equals("version")) {
                        version = fString.toString();
                        state = STATE_ENCODING;
                        if (!version.equals("1.0")) {
                            // REVISIT: report error
                            throw new SAXException("only support XML version 1.0");
                        }
                    }
                    else if (name.equals("encoding")) {
                        if (!scanningTextDecl) {
                            // REVISIT: report error
                            throw new SAXException("XMLDecl requires version pseudo-attribute");
                        }
                        encoding = fString.toString();
                        state = scanningTextDecl ? STATE_DONE : STATE_STANDALONE;
                    }
                    else {
                        // REVISIT: report error
                        if (scanningTextDecl) {
                            throw new SAXException("expected version or encoding pseudo-attribute");
                        }
                        else {
                            throw new SAXException("expected version pseudo-attribute");
                        }
                    }
                    break;
                }
                case STATE_ENCODING: {
                    if (name.equals("encoding")) {
                        encoding = fString.toString();
                        state = scanningTextDecl ? STATE_DONE : STATE_STANDALONE;
                        // TODO: check encoding name; set encoding on
                        //       entity scanner
                    }
                    else if (!scanningTextDecl && name.equals("standalone")) {
                        standalone = fString.toString();
                        state = STATE_DONE;
                        if (!standalone.equals("yes") && !standalone.equals("no")) {
                            // REVISIT: report error
                            throw new SAXException("standalone pseudo-attribute can only have values of 'yes' or 'no'");
                        }
                    }
                    else {
                        // REVISIT: report error
                        throw new SAXException("expected encoding pseudo-attribute");
                    }
                    break;
                }
                case STATE_STANDALONE: {
                    if (name.equals("standalone")) {
                        standalone = fString.toString();
                        state = STATE_DONE;
                        if (!standalone.equals("yes") && !standalone.equals("no")) {
                            // REVISIT: report error
                            throw new SAXException("standalone pseudo-attribute can only have values of 'yes' or 'no'");
                        }
                    }
                    else {
                        // REVISIT: report error
                        throw new SAXException("expected encoding pseudo-attribute");
                    }
                    break;
                }
                default: {
                    // REVISIT: report error
                    throw new SAXException("no more pseudo-attributes allowed");
                }
            }
            fEntityScanner.skipSpaces();
        }
        if ((scanningTextDecl && state != STATE_DONE) ||
            !(state == STATE_STANDALONE || state == STATE_DONE)) {
            // REVISIT: report error
            throw new SAXException("expected more pseudo-attributes");
        }

        // end
        if (!fEntityScanner.skipChar('?')) {
            // REVISIT: report error
            //throw new SAXException("expected '?'");
            fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, "XMLDeclUnterminated", 
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        if (!fEntityScanner.skipChar('>')) {
            // REVISIT: report error
            // throw new SAXException("expected '>'");
            fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, "XMLDeclUnterminated", 
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);

        }

        // call handler
        if (fDocumentHandler != null) {
            if (scanningTextDecl) {
                fDocumentHandler.textDecl(version, encoding, actualEncoding);
            }
            else {
                fDocumentHandler.xmlDecl(version, encoding, actualEncoding, standalone);
            }
        }

    } // scanXMLDeclOrTextDecl(boolean)

    /**
     * Scans a pseudo attribute.
     */
    public String scanPseudoAttribute(XMLString value) 
        throws IOException, SAXException {

        String name = fEntityScanner.scanName();
        if (name == null) {
            // REVISIT: report error
            throw new SAXException("expected pseudo-attribute name");
        }
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('=')) {
            // REVISIT: report error
            throw new SAXException("expected equals for pseudo-attribute");
        }
        fEntityScanner.skipSpaces();
        int quote = fEntityScanner.peekChar();
        if (quote != '\'' && quote != '"') {
            // REVISIT: report error
            throw new SAXException("expected quote for pseudo-attribute");
        }
        fEntityScanner.scanChar();
        // REVISIT: fix this
        fEntityScanner.scanAttContent(quote, value);
        if (!fEntityScanner.skipChar(quote)) {
            // REVISIT: report error
            throw new SAXException("expected close quote for pseudo-attribute");
        }

        // return
        return name;

    } // scanPseudoAttribute(XMLString):String
    
    /**
     * Scans a processing instruction.
     * <p>
     * <pre>
     * [16] PI ::= '&lt;?' PITarget (S (Char* - (Char* '?>' Char*)))? '?>'
     * [17] PITarget ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
     * </pre>
     */
    protected void scanPI() throws IOException, SAXException {

        // target
        String target = fEntityScanner.scanName();
        if (target == null) {
            // REVISIT: report error
            throw new SAXException("pi target expected");
        }

        // scan data
        scanPIData(target);

    } // scanPI()

    /**
     * Scans a processing data. This is needed to handle the situation
     * where a document starts with a processing instruction whose 
     * target name <em>starts with</em> "xml". (e.g. xmlfoo)
     */
    protected void scanPIData(String target) 
        throws IOException, SAXException {

        // check target
        if (target.length() == 3) {
            char c0 = Character.toLowerCase(target.charAt(0));
            char c1 = Character.toLowerCase(target.charAt(1));
            char c2 = Character.toLowerCase(target.charAt(2));
            if (c0 == 'x' && c1 == 'm' && c2 == 'l') {
                // REVISIT: report error
                throw new SAXException("MSG_RESERVED_PITARGET");
            }
        }

        // data
        // REVISIT: handle invalid character, eof
        XMLString data = fString;
        if (fEntityScanner.scanData("?>", fString)) {
            fStringBuffer.clear();
            do {
                fStringBuffer.append(fString);
            } while (fEntityScanner.scanData("?>", fString));
            fStringBuffer.append(fString);
            data = fStringBuffer;
        }

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.processingInstruction(target, data);
        }

    } // scanPIData(String)

    /**
     * Scans a comment.
     * <p>
     * <pre>
     * [15] Comment ::= '&lt!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
     * </pre>
     * <p>
     * <strong>Note:</strong> Called after scanning past '&lt;!--'
     */
    protected void scanComment() throws IOException, SAXException {

        // text
        // REVISIT: handle invalid character, eof
        fStringBuffer.clear();
        while (fEntityScanner.scanData("--", fString)) {
            fStringBuffer.append(fString);
        }
        fStringBuffer.append(fString);
        if (!fEntityScanner.skipChar('>')) {
            // REVISIT: report error
            throw new SAXException("MSG_DASH_DASH_IN_COMMENT");
        }

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.comment(fStringBuffer);
        }

    } // scanComment()
    
    /** Scans a doctype declaration. */
    protected void scanDoctypeDecl() throws IOException, SAXException {

        // spaces
        if (!fEntityScanner.skipSpaces()) {
            // REVISIT: report error
            throw new SAXException("spaces expected after <!DOCTYPE");
        }

        // root element name
        String name = fEntityScanner.scanName();
        if (name == null) {
            // REVISIT: report error
            throw new SAXException("root element name expected");
        }

        // external id
        String systemId = null;
        String publicId = null;
        boolean spaces = fEntityScanner.skipSpaces();
        if (spaces) {
            if (fEntityScanner.skipString("SYSTEM")) {
                if (!fEntityScanner.skipSpaces()) {
                    // REVISIT: report error
                    throw new SAXException("spaces required after SYSTEM");
                }
                int quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    // REVISIT: report error
                    throw new SAXException("expected quote");
                }
                fEntityScanner.scanChar();
                // REVISIT: do right
                fEntityScanner.scanAttContent(quote, fString);
                systemId = fString.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    // REVISIT: report error
                    throw new SAXException("expected quote");
                }
            }
            else if (fEntityScanner.skipString("PUBLIC")) {
                if (!fEntityScanner.skipSpaces()) {
                    // REVISIT: report error
                    throw new SAXException("spaces required after PUBLIC");
                }
                int quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    // REVISIT: report error
                    throw new SAXException("expected quote");
                }
                fEntityScanner.scanChar();
                // REVISIT: do right
                fEntityScanner.scanAttContent(quote, fString);
                publicId = fString.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    // REVISIT: report error
                    throw new SAXException("expected quote");
                }
                if (!fEntityScanner.skipSpaces()) {
                    // REVISIT: report error
                    throw new SAXException("spaces required between publicId and systemId");
                }
                quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    // REVISIT: report error
                    throw new SAXException("expected quote");
                }
                fEntityScanner.scanChar();
                // REVISIT: do right
                fEntityScanner.scanAttContent(quote, fString);
                systemId = fString.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    // REVISIT: report error
                    throw new SAXException("expected quote");
                }
            }
            fEntityScanner.skipSpaces();
        }

        // internal subset
        if (fEntityScanner.skipChar('[')) {
            // TODO: scan internal subset
            while (fEntityScanner.scanData("]", fString)) {
                // skip to end of internal subset
            }
            fEntityScanner.skipSpaces();
        }

        // end
        if (!fEntityScanner.skipChar('>')) {
            System.out.println("*** char: '"+(char)fEntityScanner.peekChar()+'\'');
            // REVISIT: report error
            throw new SAXException("expected '>' to close doctype");
        }

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.doctypeDecl(name, publicId, systemId);
        }

        // external subset
        // TODO: scan external subset

    } // scanDoctypeDecl()

    /** 
     * Scans a start element. This method will handle the binding of
     * namespace information and notifying the handler of the start
     * of the element.
     * <p>
     * <pre>
     * [44] EmptyElemTag ::= '&lt;' Name (S Attribute)* S? '/>'
     * [40] STag ::= '&lt;' Name (S Attribute)* S? '>'
     * </pre> 
     * <p>
     * <strong>Note:</strong> This method assumes that the leading
     * '&lt;' character has been consumed.
     * <p>
     * <strong>Note:</strong> This method uses the fElementQName and
     * fAttributes variables. The contents of these variables will be
     * destroyed. The caller should copy important information out of
     * these variables before calling this method.
     *
     * @returns True if element is empty. (i.e. It matches
     *          production [44].
     */
    protected boolean scanStartElement() 
        throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanStartElement()");

        // increase depth
        fElementDepth++;

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fElementQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fElementQName.setValues(null, name, name, null);
        }
        String rawname = fElementQName.rawname;

        // attributes
        boolean empty = false;
        fAttributes.clear();
        do {
            // spaces
            fEntityScanner.skipSpaces();

            // end tag?
            int c = fEntityScanner.peekChar();
            if (c == '>') {
                fEntityScanner.scanChar();
                break;
            }
            else if (c == '/') {
                fEntityScanner.scanChar();
                if (!fEntityScanner.skipChar('>')) {
                    // REVISIT: report error
                    throw new SAXException("expected '>'");
                }
                empty = true;
                break;
            }
            else if (!XMLChar.isNameStart(c)) {
                // REVISIT: report error
                throw new SAXException("expected attribute name, found '"+(char)c+'\'');
            }

            // attributes
            scanAttribute(fAttributes);

        } while (true);

        // bind namespaces
        if (fNamespaces) {
            bindNamespaces(fElementQName, fAttributes);
        }

        // push element stack
        fCurrentElement = new QName(fElementQName);
        fElementStack.push(fCurrentElement);

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.startElement(fElementQName, fAttributes);
            if (empty) {
                handleEndElement(fElementQName);
            }
        }

        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanStartElement(): "+empty);
        return empty;

    } // scanStartElement():boolean

    /** 
     * Scans an attribute.
     * <p>
     * <pre>
     * [41] Attribute ::= Name Eq AttValue
     * [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
     * </pre> 
     * <p>
     * <strong>Note:</strong> This method assumes that the next 
     * character on the stream is the first character of the attribute
     * name.
     *
     * @param attributes The attributes list for the scanned attribute.
     */
    protected void scanAttribute(XMLAttributes attributes) 
        throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanAttribute()");

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fAttributeQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fAttributeQName.setValues(null, name, name, null);
        }

        // equals
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('=')) {
            // REVISIT: report error
            throw new SAXException("expected '='");
        }
        fEntityScanner.skipSpaces();

        // quote
        int quote = fEntityScanner.peekChar();
        if (quote != '\'' && quote != '"') {
            // REVISIT: report error
            throw new SAXException("expected open quote, found '"+(char)quote+'\'');
        }
        fEntityScanner.scanChar();

        // content
        final String CDATA = fSymbolTable.addSymbol("CDATA");
        attributes.setAttribute(fAttributeQName, CDATA, null);
        XMLString value = fString;
        if (fEntityScanner.scanAttContent(quote, fString) != quote) {
            fStringBuffer.clear();
            do {
                fStringBuffer.append(fString);
                /***
                if (fEntityScanner.peekChar() == '&') {
                    // TODO: handle entities in value
                }
                /***/
            } while (fEntityScanner.scanAttContent(quote, fString) != quote);
            fStringBuffer.append(fString);
            value = fStringBuffer;
        }
        attributes.setValue(attributes.getLength() - 1, value);

        // quote
        int cquote = fEntityScanner.scanChar();
        if (cquote != cquote) {
            // REVISIT: report error
            throw new SAXException("expected close quote");
        }

        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanAttribute()");
    } // scanAttribute(XMLAttributes)

    /**
     * Scans content.
     *
     * @returns Returns the next character on the stream.
     */
    protected int scanContent() throws IOException, SAXException {

        int c = fEntityScanner.scanContent(fString);
        if (fDocumentHandler != null) {
            /*** REVISIT: Should we remove the whitespace param? -Ac
            boolean whitespace = true;
            for (int i = 0; i < fString.length; i++) {
                if (!XMLChar.isSpace(fString.ch[fString.offset + i])) {
                    whitespace = false;
                    break;
                }
            }
            fDocumentHandler.characters(fString, whitespace);
            /***/
            fDocumentHandler.characters(fString, false);
            /***/
        }
        return c;

    } // scanContent():int

    /**
     * Scans a CDATA section.
     *
     * @returns True if CDATA section is complete.
     */
    protected boolean scanCDATASection(boolean complete) 
        throws IOException, SAXException {
        throw new SAXException("not implemented");
    } // scanCDATASection(boolean):boolean

    /**
     * Scans an end element.
     * <p>
     * <pre>
     * [42] ETag ::= '&lt;/' Name S? '>'
     * </pre>
     * <p>
     * <strong>Note:</strong> This method uses the fElementQName variable.
     * The contents of this variable will be destroyed. The caller should
     * copy the needed information out of this variable before calling
     * this method.
     *
     * @returns The element depth.
     */
    protected int scanEndElement() throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanEndElement()");

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fElementQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fElementQName.setValues(null, name, name, null);
        }

        // end
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('>')) {
            // REVISIT: report error
            throw new SAXException("expected '>'");
        }

        // handle end element
        int depth = handleEndElement(fElementQName);
        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanEndElement(): "+depth);
        return depth;

    } // scanEndElement():int

    /**
     * Scans a character reference.
     * <p>
     * <pre>
     * [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
     * </pre>
     */
    protected void scanCharReference() 
        throws IOException, SAXException {

        // scan hexadecimal value
        boolean hex = false;
        if (fEntityScanner.skipChar('x')) {
            fStringBuffer.clear();
            boolean digit = true;
            do {
                int c = fEntityScanner.peekChar();
                digit = (c >= '0' && c <= '9') ||
                        (c >= 'a' && c <= 'f') ||
                        (c >= 'A' && c <= 'F');
                if (digit) {
                    fEntityScanner.scanChar();
                    fStringBuffer.append((char)c);
                }
            } while (digit);
        }

        // scan decimal value
        else {
            fStringBuffer.clear();
            boolean digit = true;
            do {
                int c = fEntityScanner.peekChar();
                digit = c >= '0' && c <= '9';
                if (digit) {
                    fEntityScanner.scanChar();
                    fStringBuffer.append((char)c);
                }
            } while (digit);
        }

        // end
        if (!fEntityScanner.skipChar(';')) {
            // REVISIT: report error
            throw new SAXException("character reference must end with semi-colon");
        }
        
        // convert string to number
        int value = -1;
        try {
            value = Integer.parseInt(fStringBuffer.toString(),
                                     hex ? 16 : 10);
        }
        catch (NumberFormatException e) {
            // let -1 value drop through
        }

        // character reference must be a valid XML character
        if (!XMLChar.isValid((char)value)) {
            // REVISIT: report error
            throw new SAXException("MSG_INVALID_CHARREF");
        }
        
        // call handler
        if (fDocumentHandler != null) {
            fSingleChar[0] = (char)value;
            fString.setValues(fSingleChar, 0, 1);
            fDocumentHandler.characters(fString, XMLChar.isSpace(value));
        }

    } // scanCharReference()

    /**
     * Scans an entity reference.
     *
     * @throws IOException  Thrown if i/o error occurs.
     * @throws SAXException Thrown if handler throws exception upon
     *                      notification.
     */
    protected void scanEntityReference() throws IOException, SAXException {

        // name
        String name = fEntityScanner.scanName();
        if (name == null) {
            // REVISIT: report error
            throw new SAXException("entity name expected");
        }

        // end
        if (!fEntityScanner.skipChar(';')) {
            // REVISIT: report error
            throw new SAXException("entity reference must end with semi-colon");
        }

        // start entity
        fEntityManager.startEntity(name);

    } // scanEntityReference()

    // utility methods

    /**
     * Binds the namespaces. This method will handle calling the
     * document handler to start the prefix mappings.
     * <p>
     * <strong>Note:</strong> This method makes use of the
     * fAttributeQName variable. Any contents of the variable will
     * be destroyed. Caller should copy the values out of this
     * temporary variable before calling this method.
     *
     * @param element    The element name.
     * @param attributes The attributes for the element.
     *
     * @throws SAXException Thrown if handler throws SAX exception upon
     *                      notification of start prefix mapping.
     */
    protected void bindNamespaces(QName element, XMLAttributes attributes)
        throws SAXException {

        // add new namespace context
        fNamespaceSupport.pushContext();

        // search for new namespace bindings
        int length = attributes.getLength();
        for (int i = 0; i < length; i++) {
            String rawname = attributes.getQName(i);
            if (rawname.startsWith("xmlns")) {
                // declare prefix in context
                String prefix = rawname.length() > 5
                              ? attributes.getLocalName(i) : "";
                String uri = attributes.getValue(i);
                fNamespaceSupport.declarePrefix(prefix, uri);

                // call handler
                if (fDocumentHandler != null) {
                    fDocumentHandler.startPrefixMapping(prefix, uri);
                }
            }
        }

        // bind the element
        String prefix = element.prefix != null
                      ? element.prefix : "";
        element.uri = fNamespaceSupport.getURI(prefix);
        if (element.prefix == null && element.uri != null) {
            element.prefix = fSymbolTable.addSymbol("");
        }
        if (element.prefix != null && element.uri == null) {
            // REVISIT: report error
            throw new SAXException("element prefix \""+element.prefix+"\" not bound");
        }

        // bind the attributes
        for (int i = 0; i < length; i++) {
            attributes.getName(i, fAttributeQName);
            String arawname = fAttributeQName.rawname;
            String aprefix = fAttributeQName.prefix != null 
                           ? fAttributeQName.prefix : "";
            if (aprefix.equals("xml")) {
                fAttributeQName.uri = NamespaceSupport.XMLNS;
                attributes.setName(i, fAttributeQName);
            }
            else if (!arawname.equals("xmlns") && !arawname.startsWith("xmlns:")) {
                if (fAttributeQName.prefix != null) {
                    fAttributeQName.uri = fNamespaceSupport.getURI(fAttributeQName.prefix);
                    if (fAttributeQName.uri == null) {
                        // REVISIT: report error
                        throw new SAXException("attribute prefix \""+fAttributeQName.prefix+"\" is not bound");
                    }
                }
                else {
                    // attributes with no prefix get element's uri
                    fAttributeQName.uri = element.uri;
                }
                attributes.setName(i, fAttributeQName);
            }
        }

    } // bindNamespaces(QName,XMLAttributes)

    /** 
     * Handles the end element. This method will make sure that
     * the end element name matches the current element and notify
     * the handler about the end of the element and the end of any
     * relevent prefix mappings.
     *
     * @param element The element.
     *
     * @returns The element depth.
     *
     * @throws SAXException Thrown if the handler throws a SAX exception
     *                      upon notification.
     */
    protected int handleEndElement(QName element) throws SAXException {

        // make sure the elements match
        QName startElement = (QName)fElementStack.pop();
        if (!element.rawname.equals(startElement.rawname)) {
            // REVISIT: report error
            throw new SAXException("end tag doesn't match start tag");
        }

        // bind namespaces
        if (fNamespaces) {
            element.uri = startElement.uri;
        }
        
        // decrease depth
        fElementDepth--;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.endElement(element);
        }

        // end prefix mappings
        if (fNamespaces) {
            // call handler
            if (fDocumentHandler != null) {
                Enumeration prefixes = fNamespaceSupport.getDeclaredPrefixes();
                while (prefixes.hasMoreElements()) {
                    String prefix = (String)prefixes.nextElement();
                    fDocumentHandler.endPrefixMapping(prefix);
                }
            }

            // pop context
            fNamespaceSupport.popContext();
        }

        return fElementDepth;

    } // callEndElement(QName):int

    // helper methods

    /**
     * Sets the scanner state.
     *
     * @param state The new scanner state.
     */
    protected final void setScannerState(int state) {

        fScannerState = state;
        if (DEBUG_SCANNER_STATE) {
            System.out.print("### setScannerState: ");
            System.out.print(getScannerStateName(state));
            System.out.println();
        }

    } // setScannerState(int)

    /**
     * Sets the dispatcher.
     *
     * @param dispatcher The new dispatcher.
     */
    protected final void setDispatcher(Dispatcher dispatcher) {
        fDispatcher = dispatcher;
        if (DEBUG_DISPATCHER) {
            System.out.print("%%% setDispatcher: ");
            System.out.print(getDispatcherName(dispatcher));
            System.out.println();
        }
    }

    //
    // Private methods
    //

    /** Returns the scanner state name. */
    private static String getScannerStateName(int state) {

        if (DEBUG_SCANNER_STATE) {
            switch (state) {
                case SCANNER_STATE_XML_DECL: return "SCANNER_STATE_XML_DECL";
                case SCANNER_STATE_START_OF_MARKUP: return "SCANNER_STATE_START_OF_MARKUP";
                case SCANNER_STATE_COMMENT: return "SCANNER_STATE_COMMENT";
                case SCANNER_STATE_PI: return "SCANNER_STATE_PI";
                case SCANNER_STATE_DOCTYPE: return "SCANNER_STATE_DOCTYPE";
                case SCANNER_STATE_PROLOG: return "SCANNER_STATE_PROLOG";
                case SCANNER_STATE_ROOT_ELEMENT: return "SCANNER_STATE_ROOT_ELEMENT";
                case SCANNER_STATE_CONTENT: return "SCANNER_STATE_CONTENT";
                case SCANNER_STATE_REFERENCE: return "SCANNER_STATE_REFERENCE";
                //case SCANNER_STATE_ATTRIBUTE_LIST: return "SCANNER_STATE_ATTRIBUTE_LIST";
                //case SCANNER_STATE_ATTRIBUTE_NAME: return "SCANNER_STATE_ATTRIBUTE_NAME";
                //case SCANNER_STATE_ATTRIBUTE_VALUE: return "SCANNER_STATE_ATTRIBUTE_VALUE";
                case SCANNER_STATE_TRAILING_MISC: return "SCANNER_STATE_TRAILING_MISC";
                case SCANNER_STATE_END_OF_INPUT: return "SCANNER_STATE_END_OF_INPUT";
                case SCANNER_STATE_TERMINATED: return "SCANNER_STATE_TERMINATED";
                case SCANNER_STATE_CDATA: return "SCANNER_STATE_CDATA";
            }
        }

        return "??? ("+state+')';

    } // getScannerStateName(int):String

    /** Returns the dispatcher name. */
    public String getDispatcherName(Dispatcher dispatcher) {

        if (DEBUG_DISPATCHER) {
            if (dispatcher != null) {
                String name = dispatcher.getClass().getName();
                int index = name.lastIndexOf('.');
                if (index != -1) {
                    name = name.substring(index + 1);
                    index = name.lastIndexOf('$');
                    if (index != -1) {
                        name = name.substring(index + 1);
                    }
                }
                return name;
            }
        }
        return "null";

    } // getDispatcherName():String

    //
    // Classes
    //

    /**
     * Entity for entity stack. 
     * <p>
     * <strong>Note:</strong> The fields in this class are public but should
     * only be set at construction time (or at the time when it is pushed
     * onto the entity stack). In other words, once pushed onto the entity
     * stack, the entity information is considered read-only.
     *
     * @author Andy Clark, IBM
     */
    protected static class Entity {

        //
        // Data
        //

        /** Entity name. */
        public String name;

        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Element depth. */
        public int elementDepth;

        //
        // Constructors
        //

        /** Constructs an entity. */
        public Entity(String name, String publicId, String systemId, 
                      int elementDepth) {
            setValues(name, publicId, systemId, elementDepth);
        } // <init>(String,String,String,int)

        //
        // Public methods
        //

        /** Clears the structure. */
        public void clear() {
            name = null;
            publicId = null;
            systemId = null;
            elementDepth = -1;
        } // clear()

        /**
         * Sets the values of this structure.
         *
         * @param name         The name.
         * @param publicId     The public identifier.
         * @param systemId     The system identifier.
         * @param elementDepth The element depth.
         */
        public void setValues(String name, String publicId, String systemid,
                              int elementDepth) {
            this.name = name;
            this.publicId = publicId;
            this.systemId = systemId;
            this.elementDepth = elementDepth;
        } // setValues(String,String,String,int)

        //
        // Object methods
        //

        /** Returns a string representation of this object. */
        public String toString() {

            StringBuffer str = new StringBuffer();
            boolean comma = false;
            if (name != null) {
                str.append("name=\"");
                str.append(name);
                str.append('"');
                comma = true;
            }
            if (publicId != null) {
                if (comma) {
                    str.append(',');
                }
                str.append("publicId=\"");
                str.append(publicId);
                str.append('"');
                comma = true;
            }
            if (systemId != null) {
                if (comma) {
                    str.append(',');
                }
                str.append("systemId=\"");
                str.append(systemId);
                str.append('"');
                comma = true;
            }
            if (elementDepth != -1) {
                if (comma) {
                    str.append(',');
                }
                str.append("elementDepth=");
                str.append(elementDepth);
            }
            return str.toString();

        } // toString():String

    } // class Entity

    /** 
     * This interface defines an XML "event" dispatching model. Classes
     * that implement this interface are responsible for scanning parts
     * of the XML document and dispatching callbacks.
     *
     * @author Glenn Marcy, IBM
     */
    protected interface Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException;

    } // interface Dispatcher

    /**
     * Dispatcher to handle XMLDecl scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class XMLDeclDispatcher 
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            // start the document
            if (fDocumentHandler != null) {
                fDocumentHandler.startDocument();
            }

            // next dispatcher is prolog regardless of whether there
            // is an XMLDecl in this document
            setScannerState(SCANNER_STATE_PROLOG);
            setDispatcher(fPrologDispatcher);

            // scan XMLDecl
            if (fEntityScanner.skipString("<?xml")) {
                // NOTE: special case where document starts with a PI
                //       whose name starts with "xml" (e.g. "xmlfoo")
                if (XMLChar.isName(fEntityScanner.peekChar())) {
                    fStringBuffer.clear();
                    fStringBuffer.append("xml");
                    while (XMLChar.isName(fEntityScanner.peekChar())) {
                        fStringBuffer.append((char)fEntityScanner.scanChar());
                    }
                    String target = fSymbolTable.addSymbol(fStringBuffer.ch, fStringBuffer.offset, fStringBuffer.length);
                    scanPIData(target);
                }

                // standard XML declaration
                else {
                    scanXMLDeclOrTextDecl(false);
                }
                return complete;
            }

            // if no XMLDecl, then scan piece of prolog
            return true;

        } // dispatch(boolean):boolean

    } // class XMLDeclDispatcher

    /**
     * Dispatcher to handle prolog scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class PrologDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            boolean again;
            do {
                again = false;
                switch (fScannerState) {
                    case SCANNER_STATE_PROLOG: {
                        fEntityScanner.skipSpaces();
                        if (fEntityScanner.skipChar('<')) {
                            setScannerState(SCANNER_STATE_START_OF_MARKUP);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('&')) {
                            setScannerState(SCANNER_STATE_REFERENCE);
                            again = true;
                        }
                        else {
                            setScannerState(SCANNER_STATE_CONTENT);
                            again = true;
                        }
                        break;
                    }
                    case SCANNER_STATE_START_OF_MARKUP: {
                        if (fEntityScanner.skipChar('?')) {
                            setScannerState(SCANNER_STATE_PI);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('!')) {
                            if (fEntityScanner.skipChar('-')) {
                                if (!fEntityScanner.skipChar('-')) {
                                    // REVISIT: report error
                                    throw new SAXException("comment must start with \"<!--\"");
                                }
                                setScannerState(SCANNER_STATE_COMMENT);
                                again = true;
                            }
                            else if (fEntityScanner.skipString("DOCTYPE")) {
                                setScannerState(SCANNER_STATE_DOCTYPE);
                                again = true;
                            }
                            else {
                                // REVISIT: report error
                                throw new SAXException("expected comment or doctype");
                            }
                        }
                        else if (XMLChar.isNameStart(fEntityScanner.peekChar())) {
                            setScannerState(SCANNER_STATE_ROOT_ELEMENT);
                            setDispatcher(fContentDispatcher);
                            return true;
                        }
                        else {
                            // REVISIT: report error
                            throw new SAXException("expected comment, pi, doctype, or root element");
                        }
                        break;
                    }
                    case SCANNER_STATE_COMMENT: {
                        scanComment();
                        setScannerState(SCANNER_STATE_PROLOG);
                        break;  
                    }
                    case SCANNER_STATE_PI: {
                        scanPI();
                        setScannerState(SCANNER_STATE_PROLOG);
                        break;  
                    }
                    case SCANNER_STATE_DOCTYPE: {
                        if (fSeenDoctypeDecl) {
                            // REVISIT: report error
                            throw new SAXException("already seen doctype");
                        }
                        fSeenDoctypeDecl = true;
                        scanDoctypeDecl();
                        setScannerState(SCANNER_STATE_PROLOG);
                        break;
                    }
                    case SCANNER_STATE_CONTENT: {
                        // REVISIT: report error
                        throw new SAXException("content not allowed in prolog");
                    }
                    case SCANNER_STATE_REFERENCE: {
                        // REVISIT: report error
                        throw new SAXException("reference not allowed in prolog");
                    }
                }
            } while (complete || again);

            if (fEntityScanner.scanChar() != '<') {
                throw new SAXException("expecting root element");
            }
            setScannerState(SCANNER_STATE_ROOT_ELEMENT);
            setDispatcher(fContentDispatcher);

            return complete;

        } // dispatch(boolean):boolean

    } // class PrologDispatcher

    /**
     * Dispatcher to handle content scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class ContentDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            boolean again;
            do {
                again = false;
                switch (fScannerState) {
                    case SCANNER_STATE_ROOT_ELEMENT: {
                        if (scanStartElement()) {
                            setScannerState(SCANNER_STATE_TRAILING_MISC);
                            setDispatcher(fTrailingMiscDispatcher);
                            return complete;
                        }
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;
                    }
                    case SCANNER_STATE_COMMENT: {
                        scanComment();
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;  
                    }
                    case SCANNER_STATE_PI: {
                        scanPI();
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;  
                    }
                    // REVISIT: Handle CDATA so that we can split up
                    //          the processing over multiple callbacks.
                    case SCANNER_STATE_CDATA: {
                        if (scanCDATASection(complete)) {
                            setScannerState(SCANNER_STATE_CONTENT);
                        }
                        break;
                    }
                    case SCANNER_STATE_REFERENCE: {
                        if (fEntityScanner.skipChar('#')) {
                            scanCharReference();
                        }
                        else {
                            scanEntityReference();
                        }
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;
                    }
                    case SCANNER_STATE_CONTENT: {
                        if (fEntityScanner.skipChar('<')) {
                            setScannerState(SCANNER_STATE_START_OF_MARKUP);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('&')) {
                            setScannerState(SCANNER_STATE_REFERENCE);
                            again = true;
                        }
                        else {
                            while (complete) {
                                int c = scanContent();
                                if (c == '<') {
                                    fEntityScanner.scanChar();
                                    setScannerState(SCANNER_STATE_START_OF_MARKUP);
                                    break;
                                }
                                else if (c == '&') {
                                    fEntityScanner.scanChar();
                                    setScannerState(SCANNER_STATE_REFERENCE);
                                    break;
                                }
                                // REVISIT: eof, invalid char
                            }
                        }
                        break;
                    }
                    case SCANNER_STATE_START_OF_MARKUP: {
                        if (fEntityScanner.skipChar('?')) {
                            setScannerState(SCANNER_STATE_PI);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('!')) {
                            if (fEntityScanner.skipChar('-')) {
                                if (!fEntityScanner.skipChar('-')) {
                                    // REVISIT: report error
                                    throw new SAXException("comment must start with \"<!--\"");
                                }
                                setScannerState(SCANNER_STATE_COMMENT);
                                again = true;
                            }
                            else if (fEntityScanner.skipString("[CDATA[")) {
                                setScannerState(SCANNER_STATE_CDATA);
                                again = true;
                            }
                            else if (fEntityScanner.skipString("DOCTYPE")) {
                                setScannerState(SCANNER_STATE_DOCTYPE);
                            }
                            else {
                                // REVISIT: report error
                                throw new SAXException("expected comment, pi, or element");
                            }
                        }
                        else if (fEntityScanner.skipChar('/')) {
                            if (scanEndElement() == 0) {
                                setScannerState(SCANNER_STATE_TRAILING_MISC);
                                setDispatcher(fTrailingMiscDispatcher);
                                return complete;
                            }
                            setScannerState(SCANNER_STATE_CONTENT);
                        }
                        else if (XMLChar.isNameStart(fEntityScanner.peekChar())) {
                            scanStartElement();
                            setScannerState(SCANNER_STATE_CONTENT);
                        }
                        else {
                            // REVISIT: report error
                            throw new SAXException("expected comment, pi, doctype, or root element");
                        }
                        break;
                    }
                    case SCANNER_STATE_DOCTYPE: {
                        // REVISIT: report error
                        throw new SAXException("doctype not allowed in content");
                    }
                }
            } while (complete || again);

            return complete;

        } // dispatch(boolean):boolean

    } // class ContentDispatcher

    /**
     * Dispatcher to handle trailing miscellaneous section scanning.
     *
     * @author Andy Clark, IBM
     * @author Eric Ye, IBM
     */
    protected final class TrailingMiscDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            do {

                if (fEntityScanner.skipChar('<')) {
                    setScannerState(SCANNER_STATE_START_OF_MARKUP);
                    if (fEntityScanner.skipChar('?')) {
                        scanPI();
                    }
                    else if ( fEntityScanner.skipChar('!')) {
                        scanComment();
                    }
                    setScannerState(SCANNER_STATE_TRAILING_MISC);
                }
                else if ( fEntityScanner.skipSpaces() ) {
                    // do nothing
                }
                else {
                    int ch = fEntityScanner.peekChar();

                    if (XMLChar.isInvalid(ch)) {
                        if (ch == -1 ) {
                            setScannerState(SCANNER_STATE_END_OF_INPUT);
                            setDispatcher(fEndOfInputDispatcher);
                            return true;
                        }
                        else {
                            // REVISIT report error
                            // throw new SAXException("invalid char in trailing Misc);
                            setScannerState(SCANNER_STATE_END_OF_INPUT);
                            setDispatcher(fEndOfInputDispatcher);
                            return false;
                        }
                    }
                    else {
                        //REVISIT: report error
                        throw new SAXException("not recognized in trailing Misc");
                    }
                }

            } while ( complete );

            setScannerState(SCANNER_STATE_END_OF_INPUT);
            setDispatcher(fEndOfInputDispatcher);
            return true;

        } // dispatch(boolean):boolean

    } // class TrailingMiscDispatcher

    /**
     * Dispatcher to handle end of input processing.
     *
     * @author Andy Clark, IBM
     */
    protected final class EndOfInputDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            // TODO

            // end the document
            if (fDocumentHandler != null) {
                fDocumentHandler.endDocument();
            }
            return false;

        } // dispatch(boolean):boolean

    } // class EndOfInputDispatcher

} // class XMLDocumentScanner
