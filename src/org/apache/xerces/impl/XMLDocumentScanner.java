/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import java.io.EOFException;
import java.io.IOException;
import java.util.Stack;

import org.apache.xerces.impl.XMLEntityManager;
import org.apache.xerces.impl.XMLEntityScanner;
import org.apache.xerces.impl.XMLErrorReporter;
import org.apache.xerces.impl.msg.XMLMessageFormatter;

import org.apache.xerces.util.XMLAttributesImpl;
import org.apache.xerces.util.XMLStringBuffer;
import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.XMLChar;

import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLAttributes;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLDocumentHandler;
import org.apache.xerces.xni.XMLDocumentSource;
import org.apache.xerces.xni.XMLString;

import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

/**
 * This class is responsible for scanning XML document structure
 * and content. The scanner acts as the source for the document
 * information which is communicated to the document handler.
 * <p>
 * This component requires the following features and properties from the
 * component manager that uses it:
 * <ul>
 *  <li>http://xml.org/sax/features/namespaces</li>
 *  <li>http://apache.org/xml/properties/internal/symbol-table</li>
 *  <li>http://apache.org/xml/properties/internal/error-reporter</li>
 *  <li>http://apache.org/xml/properties/internal/entity-manager</li>
 * </ul>
 *
 * @author Glenn Marcy, IBM
 * @author Stubs generated by DesignDoc on Mon Sep 11 11:10:57 PDT 2000
 * @author Andy Clark, IBM
 *
 * @version $Id$
 */
public class XMLDocumentScanner
    extends XMLScanner
    implements XMLComponent, XMLDocumentSource, XMLEntityHandler {

    //
    // Constants
    //

    // scanner states

    /** Scanner state: XML declaration. */
    protected static final int SCANNER_STATE_XML_DECL = 0;

    /** Scanner state: start of markup. */
    protected static final int SCANNER_STATE_START_OF_MARKUP = 1;

    /** Scanner state: comment. */
    protected static final int SCANNER_STATE_COMMENT = 2;

    /** Scanner state: processing instruction. */
    protected static final int SCANNER_STATE_PI = 3;

    /** Scanner state: DOCTYPE. */
    protected static final int SCANNER_STATE_DOCTYPE = 4;

    /** Scanner state: prolog. */
    protected static final int SCANNER_STATE_PROLOG = 5;

    /** Scanner state: root element. */
    protected static final int SCANNER_STATE_ROOT_ELEMENT = 6;

    /** Scanner state: content. */
    protected static final int SCANNER_STATE_CONTENT = 7;

    /** Scanner state: reference. */
    protected static final int SCANNER_STATE_REFERENCE = 8;

    /** Scanner state: attribute list. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_LIST = 9;

    /** Scanner state: attribute name. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_NAME = 10;

    /** Scanner state: attribute value. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_VALUE = 11;

    /** Scanner state: trailing misc. */
    protected static final int SCANNER_STATE_TRAILING_MISC = 12;

    /** Scanner state: end of input. */
    protected static final int SCANNER_STATE_END_OF_INPUT = 13;

    /** Scanner state: terminated. */
    protected static final int SCANNER_STATE_TERMINATED = 14;

    /** Scanner state: CDATA section. */
    protected static final int SCANNER_STATE_CDATA = 15;

    /** Scanner state: Text declaration. */
    protected static final int SCANNER_STATE_TEXT_DECL = 16;

    // debugging

    /** Debug scanner state. */
    private static final boolean DEBUG_SCANNER_STATE = false;

    /** Debug dispatcher. */
    private static final boolean DEBUG_DISPATCHER = false;

    /** Debug content dispatcher scanning. */
    private static final boolean DEBUG_CONTENT_SCANNING = false;

    /** Debug attribute entities. */
    private static final boolean DEBUG_ATTR_ENTITIES = false;

    //
    // Data
    //

    // properties

    /** DTD scanner. */
    protected XMLDTDScanner fDTDScanner;

    // protected data

    /** Document handler. */
    protected XMLDocumentHandler fDocumentHandler;

    /** Entity stack. */
    protected int[] fEntityStack = new int[4];

    /** Entity depth. */
    protected int fEntityDepth;

    /** True if we started some markup. */
    protected boolean fInMarkup;

    /** Scanner state. */
    protected int fScannerState;

    /** Seen doctype declaration. */
    protected boolean fSeenDoctypeDecl;
    
    /** Standalone. */
    protected boolean fStandalone;

    /** Scanning attribute. */
    protected boolean fScanningAttribute;

    /** Scanning DTD. */
    protected boolean fScanningDTD;

    // element information

    /** Element depth. */
    protected int fElementDepth;

    /** Current element. */
    protected QName fCurrentElement;

    /** Element stack. */
    protected ElementStack fElementStack = new ElementStack();

    /** Attribute entity stack. */
    protected AttrEntityStack fAttributeEntityStack = new AttrEntityStack();

    /** Attribute value offset. */
    protected int fAttributeOffset;

    // features

    /** Namespaces. */
    protected boolean fNamespaces;

    // dispatchers

    /** Active dispatcher. */
    protected Dispatcher fDispatcher;

    /** XML declaration dispatcher. */
    protected Dispatcher fXMLDeclDispatcher = new XMLDeclDispatcher();

    /** Prolog dispatcher. */
    protected Dispatcher fPrologDispatcher = new PrologDispatcher();

    /** Content dispatcher. */
    protected Dispatcher fContentDispatcher = new ContentDispatcher();

    /** Trailing miscellaneous section dispatcher. */
    protected Dispatcher fTrailingMiscDispatcher = new TrailingMiscDispatcher();

    // private data

    /** Element QName. */
    private QName fElementQName = new QName();

    /** Attribute QName. */
    private QName fAttributeQName = new QName();

    /** Element attributes. */
    private XMLAttributesImpl fAttributes = new XMLAttributesImpl();

    /** Single character array. */
    private final char[] fSingleChar = new char[1];

    /** External entity. */
    private XMLEntityManager.ExternalEntity fExternalEntity = new XMLEntityManager.ExternalEntity();

    /** Pseudo-attribute values. */
    private String[] fPseudoAttributeValues = new String[3];

    // symbols

    /** Symbol: "amp". */
    private String fAmpSymbol;

    /** Symbol: "lt". */
    private String fLtSymbol;

    /** Symbol: "gt". */
    private String fGtSymbol;

    /** Symbol: "quot". */
    private String fQuotSymbol;

    /** Symbol: "apos". */
    private String fAposSymbol;

    /** Symbol: "CDATA". */
    private String fCDATASymbol;

    //
    // Constructors
    //

    /** Default constructor. */
    public XMLDocumentScanner() {
    } // <init>()

    //
    // Public methods
    //

    /** 
     * Scans a document. 
     * <p>
     * <strong>Note:</strong> The caller of this method is responsible
     * for having called <code>reset(XMLComponentManager)</code> before
     * any scanning and having initialized the entity manager by starting 
     * the document entity.
     *
     * @param complete True to completely scan the rest of the document.
     *
     * @returns True if scanning is not finished.
     */
    public boolean scanDocument(boolean complete) 
        throws IOException, SAXException {

        // keep dispatching "events"
        do {
            if (!fDispatcher.dispatch(complete)) {
                return false;
            }
        } while (complete);

        // return success
        return true;

    } // scanDocument(boolean):boolean

    //
    // XMLComponent methods
    //

    /**
     * 
     * 
     * @param componentManager The component manager.
     *
     * @throws SAXException Throws exception if required features and
     *                      properties cannot be found.
     */
    public void reset(XMLComponentManager componentManager)
        throws SAXException {

        super.reset(componentManager);

        // sax features
        final String NAMESPACES = Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
        fNamespaces = componentManager.getFeature(NAMESPACES);
        fAttributes.setNamespaces(fNamespaces);

        // xerces properties
        final String DTD_SCANNER = Constants.XERCES_PROPERTY_PREFIX + Constants.DTD_SCANNER_PROPERTY;
        fDTDScanner = (XMLDTDScanner)componentManager.getProperty(DTD_SCANNER);

        // initialize vars
        fEntityDepth = 0;
        fInMarkup = false;
        fElementDepth = 0;
        fCurrentElement = null;
        fElementStack.clear();
        fSeenDoctypeDecl = false;
        fStandalone = false;
        fScanningDTD = false;

        // save built-in entity names
        fAmpSymbol = fSymbolTable.addSymbol("amp");
        fLtSymbol = fSymbolTable.addSymbol("lt");
        fGtSymbol = fSymbolTable.addSymbol("gt");
        fQuotSymbol = fSymbolTable.addSymbol("quot");
        fAposSymbol = fSymbolTable.addSymbol("apos");
        fCDATASymbol = fSymbolTable.addSymbol("CDATA");

        // setup dispatcher
        setScannerState(SCANNER_STATE_XML_DECL);
        setDispatcher(fXMLDeclDispatcher);
        
    } // reset(XMLComponentManager)

    /**
     * Sets the state of a feature during parsing.
     * 
     * @param featureId 
     * @param state 
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setFeature(String,boolean)

    /**
     * Sets the value of a property during parsing.
     * 
     * @param propertyId 
     * @param value 
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        
        super.setProperty(propertyId, value);

        // Xerces properties
        if (propertyId.startsWith(Constants.XERCES_PROPERTY_PREFIX)) {
            String property = propertyId.substring(Constants.XERCES_PROPERTY_PREFIX.length());
            if (property.equals(Constants.DTD_SCANNER_PROPERTY)) {
                fDTDScanner = (XMLDTDScanner)value;
            }
            else if (property.equals(Constants.ENTITY_MANAGER_PROPERTY)) {
                fEntityManager = (XMLEntityManager)value;
            }
            return;
        }

    } // setProperty(String,Object)

    //
    // XMLDocumentSource methods
    //

    /**
     * setDocumentHandler
     * 
     * @param documentHandler 
     */
    public void setDocumentHandler(XMLDocumentHandler documentHandler) {
        fDocumentHandler = documentHandler;
    } // setDocumentHandler(XMLDocumentHandler)

    //
    // XMLEntityHandler methods
    //

    /**
     * This method notifies of the start of an entity. The document entity
     * has the pseudo-name of "[xml]"; the DTD has the pseudo-name of "[dtd]; 
     * parameter entity names start with '%'; and general entities are just
     * specified by their name.
     * 
     * @param name     The name of the entity.
     * @param publicId The public identifier of the entity if the entity
     *                 is external, null otherwise.
     * @param systemId The system identifier of the entity if the entity
     *                 is external, null otherwise.
     * @param encoding The auto-detected IANA encoding name of the entity
     *                 stream. This value will be null in those situations
     *                 where the entity encoding is not auto-detected (e.g.
     *                 internal entities or a document entity that is
     *                 parsed from a java.io.Reader).
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startEntity(String name, String publicId, String systemId,
                            String encoding) throws SAXException {

        // keep track of this entity
        if (fEntityDepth == fEntityStack.length) {
            int[] entityarray = new int[fEntityStack.length * 2];
            System.arraycopy(fEntityStack, 0, entityarray, 0, fEntityStack.length);
            fEntityStack = entityarray;
        }
        fEntityStack[fEntityDepth++] = fElementDepth;

        // prepare to look for a TextDecl if external general entity
        if (!name.equals("[xml]") && fEntityScanner.isExternal()) {
            setScannerState(SCANNER_STATE_TEXT_DECL);
        }

        // keep track of entities appearing in attribute values
        if (fScanningAttribute) {
            if (DEBUG_ATTR_ENTITIES) {
                System.out.println("*** pushAttrEntity("+name+','+fAttributeOffset+')');
            }
            fAttributeEntityStack.pushAttrEntity(name, fAttributeOffset);
        }

        // call handler
        if (fDocumentHandler != null) {
            if (!fScanningAttribute) {
                fDocumentHandler.startEntity(name, publicId, systemId, encoding);
            }
            if (name.equals("[xml]")) {
                fDocumentHandler.startDocument();
            }
        }

    } // startEntity(String,String,String,String)

    /**
     * This method notifies the end of an entity. The document entity has
     * the pseudo-name of "[xml]"; the DTD has the pseudo-name of "[dtd]; 
     * parameter entity names start with '%'; and general entities are just
     * specified by their name.
     * 
     * @param name The name of the entity.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endEntity(String name) throws SAXException {

        // make sure elements are balanced
        int elementDepth = fEntityStack[--fEntityDepth];
        if (fElementDepth != elementDepth) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, "ElementEntityMismatch", 
                                       new Object[]{fCurrentElement.rawname}, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // keep track of entities appearing in attribute values
        if (fScanningAttribute) {
            if (DEBUG_ATTR_ENTITIES) {
                System.out.println("*** popAttrEntity("+fAttributeOffset+") \""+name+'"');
            }
            fAttributeEntityStack.popAttrEntity(fAttributeOffset);
        }

        // make sure markup is properly balanced
        else if (fInMarkup) {
            fInMarkup = false;
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "MarkupEntityMismatch",
                                       null,
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // call handler
        if (fDocumentHandler != null) {
            if (name.equals("[xml]")) {
                fDocumentHandler.endDocument();
            }
            if (!fScanningAttribute) {
                fDocumentHandler.endEntity(name);
            }
        }
        
    } // endEntity(String)

    //
    // Protected methods
    //

    // scanning methods

    /**
     * Scans an XML or text declaration.
     * <p>
     * <pre>
     * [23] XMLDecl ::= '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
     * [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ")
     * [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' |  "'" EncName "'" )
     * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
     * [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'")
     *                 | ('"' ('yes' | 'no') '"'))
     *
     * [77] TextDecl ::= '&lt;?xml' VersionInfo? EncodingDecl S? '?>'
     * </pre>
     *
     * @param scanningTextDecl True if a text declaration is to
     *                         be scanned instead of an XML
     *                         declaration.
     */
    protected void scanXMLDeclOrTextDecl(boolean scanningTextDecl) 
        throws IOException, SAXException {

        // scan decl
        super.scanXMLDeclOrTextDecl(scanningTextDecl, fPseudoAttributeValues);
        fInMarkup = false;

        // pseudo-attribute values
        String version = fPseudoAttributeValues[0];
        String encoding = fPseudoAttributeValues[1];
        String standalone = fPseudoAttributeValues[2];

        // set standalone
        fStandalone = standalone != null && standalone.equals("yes");
        fEntityManager.setStandalone(fStandalone);

        // call handler
        if (fDocumentHandler != null) {
            if (scanningTextDecl) {
                fDocumentHandler.textDecl(version, encoding);
            }
            else {
                fDocumentHandler.xmlDecl(version, encoding, standalone);
            }
        }

        // set encoding on reader
        if (encoding != null) {
            fEntityScanner.setEncoding(encoding);
        }

    } // scanXMLDeclOrTextDecl(boolean)

    /**
     * Scans a processing data. This is needed to handle the situation
     * where a document starts with a processing instruction whose 
     * target name <em>starts with</em> "xml". (e.g. xmlfoo)
     *
     * @param target The PI target
     * @param data The string to fill in with the data
     */
    protected void scanPIData(String target, XMLString data) 
        throws IOException, SAXException {

        super.scanPIData(target, data);
        fInMarkup = false;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.processingInstruction(target, data);
        }

    } // scanPIData(String)

    /**
     * Scans a comment.
     * <p>
     * <pre>
     * [15] Comment ::= '&lt!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
     * </pre>
     * <p>
     * <strong>Note:</strong> Called after scanning past '&lt;!--'
     */
    protected void scanComment() throws IOException, SAXException {

        scanComment(fStringBuffer);
        fInMarkup = false;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.comment(fStringBuffer);
        }

    } // scanComment()
    
    /** Scans a doctype declaration. */
    protected void scanDoctypeDecl() throws IOException, SAXException {

        // spaces
        if (!fEntityScanner.skipSpaces()) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // root element name
        String name = fEntityScanner.scanName();
        if (name == null) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "MSG_ROOT_ELEMENT_TYPE_REQUIRED",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // external id
        String systemId = null;
        String publicId = null;
        boolean spaces = fEntityScanner.skipSpaces();
        if (spaces) {
            if (fEntityScanner.skipString("SYSTEM")) {
                if (!fEntityScanner.skipSpaces()) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SpaceRequiredAfterSYSTEM",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                int quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "QuoteRequiredInSystemID",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                fEntityScanner.scanChar();
                XMLString value = fString;
                if (fEntityScanner.scanLiteral(quote, fString) != quote) {
                    fStringBuffer.clear();
                    do {
                        fStringBuffer.append(fString);
                        fStringBuffer.append((char)fEntityScanner.scanChar());
                    } while (fEntityScanner.scanLiteral(quote, fString) != quote);
                    fStringBuffer.append(fString);
                    value = fStringBuffer;
                }
                systemId = value.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SystemIDUnterminated",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
            }
            else if (fEntityScanner.skipString("PUBLIC")) {
                if (!fEntityScanner.skipSpaces()) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                             "SpaceRequiredAfterPUBLIC",
                             null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                int quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "QuoteRequiredInPublicID",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                fEntityScanner.scanChar();
                XMLString value = fString;
                if (fEntityScanner.scanLiteral(quote, fString) != quote) {
                    fStringBuffer.clear();
                    do {
                        fStringBuffer.append(fString);
                        fStringBuffer.append((char)fEntityScanner.scanChar());
                    } while (fEntityScanner.scanLiteral(quote, fString) != quote);
                    fStringBuffer.append(fString);
                    value = fStringBuffer;
                }
                publicId = value.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "PublicIDUnterminated",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                if (!fEntityScanner.skipSpaces()) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SpaceRequiredBetweenPublicAndSystem",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "QuoteRequiredInSystemID",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                fEntityScanner.scanChar();
                value = fString;
                if (fEntityScanner.scanLiteral(quote, fString) != quote) {
                    fStringBuffer.clear();
                    do {
                        fStringBuffer.append(fString);
                        fStringBuffer.append((char)fEntityScanner.scanChar());
                    } while (fEntityScanner.scanLiteral(quote, fString) != quote);
                    fStringBuffer.append(fString);
                    value = fStringBuffer;
                }
                systemId = value.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SystemIDUnterminated",
                                               null, 
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
            }
            fEntityScanner.skipSpaces();
        }

        // internal subset
        if (fEntityScanner.skipChar('[')) {
            fEntityManager.setEntityHandler(fDTDScanner);
            final boolean complete = true;
            final boolean hasExternalDTD = systemId != null;
            fDTDScanner.scanDTDInternalSubset(complete, fStandalone, hasExternalDTD);
            fEntityManager.setEntityHandler(this);
            // REVISIT: Do we need to emit an error here? We can usually
            //          assume that it will be consumed by the DTD scanner
            //          or else the DTD scanner will fail on seeing the
            //          document content. However, there is the continue-
            //          after-fatal-error setting... -Ac
            if (!fEntityScanner.skipChar(']')) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "EXPECTED_SQUARE_BRACKET_TO_CLOSE_INTERNAL_SUBSET",
                                           null,
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }
            fEntityScanner.skipSpaces();
        }

        // end
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('>')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "DoctypedeclUnterminated",
                                       new Object[]{name},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fInMarkup = false;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.doctypeDecl(name, publicId, systemId);
        }

        // external subset
        if (systemId != null) {
            XMLInputSource xmlInputSource = 
                fEntityManager.resolveEntity(publicId, systemId, null);
            fEntityManager.setEntityHandler(fDTDScanner);
            fEntityManager.startDTDEntity(xmlInputSource);
            final boolean complete = true;
            fDTDScanner.scanDTD(complete);
            fEntityManager.setEntityHandler(this);
        }

        // external subset
        // TODO: scan external subset

    } // scanDoctypeDecl()

    /** 
     * Scans a start element. This method will handle the binding of
     * namespace information and notifying the handler of the start
     * of the element.
     * <p>
     * <pre>
     * [44] EmptyElemTag ::= '&lt;' Name (S Attribute)* S? '/>'
     * [40] STag ::= '&lt;' Name (S Attribute)* S? '>'
     * </pre> 
     * <p>
     * <strong>Note:</strong> This method assumes that the leading
     * '&lt;' character has been consumed.
     * <p>
     * <strong>Note:</strong> This method uses the fElementQName and
     * fAttributes variables. The contents of these variables will be
     * destroyed. The caller should copy important information out of
     * these variables before calling this method.
     *
     * @returns True if element is empty. (i.e. It matches
     *          production [44].
     */
    protected boolean scanStartElement() 
        throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanStartElement()");

        // increase depth
        fElementDepth++;

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fElementQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fElementQName.setValues(null, name, name, null);
        }
        String rawname = fElementQName.rawname;

        // attributes
        boolean empty = false;
        fAttributes.removeAllAttributes();
        do {
            // spaces
            fEntityScanner.skipSpaces();

            // end tag?
            int c = fEntityScanner.peekChar();
            if (c == '>') {
                fEntityScanner.scanChar();
                break;
            }
            else if (c == '/') {
                fEntityScanner.scanChar();
                if (!fEntityScanner.skipChar('>')) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "ElementUnterminated",
                                               new Object[]{rawname},
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                empty = true;
                break;
            }
            else if (!XMLChar.isNameStart(c)) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "ElementUnterminated",
                                           new Object[]{rawname},
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }

            // attributes
            scanAttribute(fAttributes);

        } while (true);
        fInMarkup = false;

        // push element stack
        fCurrentElement = fElementStack.pushElement(fElementQName);

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.startElement(fElementQName, fAttributes);
            if (empty) {
                handleEndElement(fElementQName);
            }
        }

        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanStartElement(): "+empty);
        return empty;

    } // scanStartElement():boolean

    /** 
     * Scans an attribute.
     * <p>
     * <pre>
     * [41] Attribute ::= Name Eq AttValue
     * [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
     * </pre> 
     * <p>
     * <strong>Note:</strong> This method assumes that the next 
     * character on the stream is the first character of the attribute
     * name.
     *
     * @param attributes The attributes list for the scanned attribute.
     */
    protected void scanAttribute(XMLAttributes attributes) 
        throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanAttribute()");

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fAttributeQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fAttributeQName.setValues(null, name, name, null);
        }

        // equals
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('=')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "EqRequiredInAttribute",
                                       new Object[]{fCurrentElement.rawname, fAttributeQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fEntityScanner.skipSpaces();

        // quote
        int quote = fEntityScanner.peekChar();
        if (quote != '\'' && quote != '"') {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "OpenQuoteExpected",
                                       new Object[]{fAttributeQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fEntityScanner.scanChar();
        int entityDepth = fEntityDepth;

        // content
        attributes.addAttribute(fAttributeQName, fCDATASymbol, null);
        XMLString value = fString;
        int c = fEntityScanner.scanLiteral(quote, fString);
        if (c != quote) {
            fScanningAttribute = true;
            int attrIndex = attributes.getLength() - 1;
            if (DEBUG_ATTR_ENTITIES) {
                System.out.println("*** reset attribute entity stack");
            }
            fAttributeEntityStack.reset(attributes, attrIndex);
            fAttributeOffset = 0;
            if (DEBUG_ATTR_ENTITIES) {
                System.out.println("*** set attribute offset: "+fAttributeOffset);
            }
            fStringBuffer.clear();
            do {
                fStringBuffer.append(fString);
                fAttributeOffset += fString.length;
                if (DEBUG_ATTR_ENTITIES) {
                    System.out.println("*** increment attribute offset: "+fAttributeOffset);
                }
                if (c == '&') {
                    fEntityScanner.skipChar('&');
                    if (fEntityScanner.skipChar('#')) {
                        int cv = scanCharReferenceValue();
                        if (cv != -1) {
                            fStringBuffer.append((char)cv);
                            fAttributeOffset++;
                            if (DEBUG_ATTR_ENTITIES) {
                                System.out.println("*** increment attribute offset: "+fAttributeOffset);
                            }
                        }
                    }
                    else {
                        String entityName = fEntityScanner.scanName();
                        if (entityName == null) {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "NameRequiredInReference",
                                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                        if (!fEntityScanner.skipChar(';')) {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "SemicolonRequiredInReference",
                                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                        if (entityName == fAmpSymbol) {
                            fStringBuffer.append('&');
                            fAttributeOffset++;
                            if (DEBUG_ATTR_ENTITIES) {
                                System.out.println("*** increment attribute offset: "+fAttributeOffset);
                            }
                        }
                        else if (entityName == fAposSymbol) {
                            fStringBuffer.append('\'');
                            fAttributeOffset++;
                            if (DEBUG_ATTR_ENTITIES) {
                                System.out.println("*** increment attribute offset: "+fAttributeOffset);
                            }
                        }
                        else if (entityName == fLtSymbol) {
                            fStringBuffer.append('<');
                            fAttributeOffset++;
                            if (DEBUG_ATTR_ENTITIES) {
                                System.out.println("*** increment attribute offset: "+fAttributeOffset);
                            }
                        }
                        else if (entityName == fGtSymbol) {
                            fStringBuffer.append('>');
                            fAttributeOffset++;
                            if (DEBUG_ATTR_ENTITIES) {
                                System.out.println("*** increment attribute offset: "+fAttributeOffset);
                            }
                        }
                        else if (entityName == fQuotSymbol) {
                            fStringBuffer.append('"');
                            fAttributeOffset++;
                            if (DEBUG_ATTR_ENTITIES) {
                                System.out.println("*** increment attribute offset: "+fAttributeOffset);
                            }
                        }
                        else {
                            int odepth = fEntityDepth;
                            fEntityManager.startEntity(entityName, false);
                            int ndepth = fEntityDepth;
                            // if we actually got a new entity and it's external
                            // parse text decl if there is any
                            if (odepth != ndepth) {
                                if (fEntityScanner.isExternal()) {
                                    if (DEBUG_ATTR_ENTITIES) {
                                        System.out.println("*** scanning TextDecl");
                                    }
                                    if (fEntityScanner.skipString("<?xml")) {
                                        fInMarkup = true;
                                        scanXMLDeclOrTextDecl(true);
                                    }
                                }
                            }
                        }
                    }
                }
                else if (c == '<') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "LessthanInAttValue",
                                               new Object[] { null, fAttributeQName.rawname }, 
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                else if (c != -1 && XMLChar.isInvalid(c)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                               "InvalidCharInAttValue",
                                               new Object[] {Integer.toString(c, 16)},
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    fEntityScanner.scanChar();
                }
                while (true) {
                    c = fEntityScanner.scanLiteral(quote, fString);
                    if (c != quote || entityDepth == fEntityDepth) {
                        break;
                    }
                    fStringBuffer.append(fString);
                    fStringBuffer.append((char)fEntityScanner.scanChar());
                }
            } while (c != quote);
            fAttributeOffset += fString.length;
            fStringBuffer.append(fString);
            value = fStringBuffer;
            int attrEntityCount = fAttributeEntityStack.size();
            if (DEBUG_ATTR_ENTITIES) {
                System.out.println("*** add remaining attribute entities: "+attrEntityCount);
            }
            for (int i = 0; i < attrEntityCount; i++) {
                if (DEBUG_ATTR_ENTITIES) {
                    System.out.println("*** popAttrEntity("+fAttributeOffset+')');
                }
                fAttributeEntityStack.popAttrEntity(fAttributeOffset);
            }
            fScanningAttribute = false;
        }
        attributes.setValue(attributes.getLength() - 1, value.toString());

        // quote
        int cquote = fEntityScanner.scanChar();
        if (cquote != cquote) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "CloseQuoteExpected",
                                       new Object[]{fAttributeQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanAttribute()");
    } // scanAttribute(XMLAttributes)

    /**
     * Scans content.
     *
     * @returns Returns the next character on the stream.
     */
    protected int scanContent() throws IOException, SAXException {

        int c = fEntityScanner.scanContent(fString);
        if (fDocumentHandler != null && fString.length > 0) {
            fDocumentHandler.characters(fString);
        }

        // REVISIT: Handle this better.
        if (c == ']' && fString.length == 0) {
            if (fEntityScanner.skipString("]]>")) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "CDEndInContent",
                                           null,
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }
            else if (fEntityScanner.skipString("]]")) {
                fStringBuffer.clear();
                fStringBuffer.append("]]");
                if (fDocumentHandler != null) {
                    fDocumentHandler.characters(fStringBuffer);
                }
            }
            else {
                fStringBuffer.clear();
                fStringBuffer.append((char)fEntityScanner.scanChar());
                if (fDocumentHandler != null) {
                    fDocumentHandler.characters(fStringBuffer);
                }
            }
            c = -1;
        }
        return c;

    } // scanContent():int

    /** 
     * Scans a CDATA section. 
     * <p>
     * <strong>Note:</strong> This method uses the fString and
     * fStringBuffer variables.
     *
     * @param complete True if the CDATA section is to be scanned
     *                 completely.
     *
     * @return True if CDATA is completely scanned.
     */
    protected boolean scanCDATASection(boolean complete) 
        throws IOException, SAXException {
        
        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.startCDATA();
        }

        while (true) {
            if (!fEntityScanner.scanData("]]", fString)) {
                if (fDocumentHandler != null && fString.length > 0) {
                    fDocumentHandler.characters(fString);
                }
                int brackets = 2;
                while (fEntityScanner.skipChar(']')) {
                    brackets++;
                }
                if (fDocumentHandler != null && brackets > 2) {
                    fStringBuffer.clear();
                    for (int i = 2; i < brackets; i++) {
                        fStringBuffer.append(']');
                    }
                    fDocumentHandler.characters(fStringBuffer);
                }
                if (fEntityScanner.skipChar('>')) {
                    break;
                }
                if (fDocumentHandler != null) {
                    fStringBuffer.clear();
                    fStringBuffer.append("]]");
                    fDocumentHandler.characters(fStringBuffer);
                }
            }
            else {
                int c = fEntityScanner.peekChar();
                if (c != -1 && XMLChar.isInvalid(c)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                               "InvalidCharInCDSect",
                                               new Object[] {Integer.toString(c, 16)},
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    fEntityScanner.scanChar();
                }
                if (fDocumentHandler != null) {
                    fDocumentHandler.characters(fString);
                }
            }
        }
        fInMarkup = false;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.endCDATA();
        }

        return true;

    } // scanCDATASection(boolean):boolean

    /**
     * Scans an end element.
     * <p>
     * <pre>
     * [42] ETag ::= '&lt;/' Name S? '>'
     * </pre>
     * <p>
     * <strong>Note:</strong> This method uses the fElementQName variable.
     * The contents of this variable will be destroyed. The caller should
     * copy the needed information out of this variable before calling
     * this method.
     *
     * @returns The element depth.
     */
    protected int scanEndElement() throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanEndElement()");

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fElementQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fElementQName.setValues(null, name, name, null);
        }

        // end
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('>')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "ETagUnterminated",
                                       new Object[]{fElementQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fInMarkup = false;

        // handle end element
        int depth = handleEndElement(fElementQName);
        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanEndElement(): "+depth);
        return depth;

    } // scanEndElement():int

    /**
     * Scans a character reference.
     * <p>
     * <pre>
     * [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
     * </pre>
     */
    protected void scanCharReference() 
        throws IOException, SAXException {

        int value = scanCharReferenceValue();

        // call handler
        if (fDocumentHandler != null) {
            fSingleChar[0] = (char)value;
            fString.setValues(fSingleChar, 0, 1);
            fDocumentHandler.characters(fString);
        }

    } // scanCharReference()

    /**
     * Scans an entity reference.
     *
     * @throws IOException  Thrown if i/o error occurs.
     * @throws SAXException Thrown if handler throws exception upon
     *                      notification.
     */
    protected void scanEntityReference() throws IOException, SAXException {

        // name
        String name = fEntityScanner.scanName();
        if (name == null) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "NameRequiredInReference",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // end
        if (!fEntityScanner.skipChar(';')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "SemicolonRequiredInReference",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fInMarkup = false;

        // handle built-in entities
        if (name == fAmpSymbol) {
            handleCharacter('&');
        }
        else if (name == fLtSymbol) {
            handleCharacter('<');
        }
        else if (name == fGtSymbol) {
            handleCharacter('>');
        }
        else if (name == fQuotSymbol) {
            handleCharacter('"');
        }
        else if (name == fAposSymbol) {
            handleCharacter('\'');
        }
        
        // start general entity
        else {
            fEntityManager.startEntity(name, false);
        }

    } // scanEntityReference()

    // utility methods

    /** 
     * Calls document handler with a single character. 
     *
     * @param c
     */
    protected void handleCharacter(char c) throws SAXException {
        if (fDocumentHandler != null) {
            fSingleChar[0] = c;
            fString.setValues(fSingleChar, 0, 1);
            fDocumentHandler.characters(fString);
        }
    } // handleCharacter(char)

    /** 
     * Handles the end element. This method will make sure that
     * the end element name matches the current element and notify
     * the handler about the end of the element and the end of any
     * relevent prefix mappings.
     *
     * @param element The element.
     *
     * @returns The element depth.
     *
     * @throws SAXException Thrown if the handler throws a SAX exception
     *                      upon notification.
     */
    protected int handleEndElement(QName element) throws SAXException {

        // make sure the elements match
        QName startElement = fElementQName;
        fElementStack.popElement(startElement);
        if (element.rawname != startElement.rawname) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "ETagRequired",
                                       new Object[]{startElement.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // bind namespaces
        if (fNamespaces) {
            element.uri = startElement.uri;
        }
        
        // decrease depth
        fElementDepth--;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.endElement(element);
        }

        return fElementDepth;

    } // callEndElement(QName):int

    // helper methods

    /**
     * Sets the scanner state.
     *
     * @param state The new scanner state.
     */
    protected final void setScannerState(int state) {

        fScannerState = state;
        if (DEBUG_SCANNER_STATE) {
            System.out.print("### setScannerState: ");
            System.out.print(getScannerStateName(state));
            System.out.println();
        }

    } // setScannerState(int)

    /**
     * Sets the dispatcher.
     *
     * @param dispatcher The new dispatcher.
     */
    protected final void setDispatcher(Dispatcher dispatcher) {
        fDispatcher = dispatcher;
        if (DEBUG_DISPATCHER) {
            System.out.print("%%% setDispatcher: ");
            System.out.print(getDispatcherName(dispatcher));
            System.out.println();
        }
    }

    //
    // Private methods
    //

    /** Returns the scanner state name. */
    private static String getScannerStateName(int state) {

        if (DEBUG_SCANNER_STATE) {
            switch (state) {
                case SCANNER_STATE_XML_DECL: return "SCANNER_STATE_XML_DECL";
                case SCANNER_STATE_START_OF_MARKUP: return "SCANNER_STATE_START_OF_MARKUP";
                case SCANNER_STATE_COMMENT: return "SCANNER_STATE_COMMENT";
                case SCANNER_STATE_PI: return "SCANNER_STATE_PI";
                case SCANNER_STATE_DOCTYPE: return "SCANNER_STATE_DOCTYPE";
                case SCANNER_STATE_PROLOG: return "SCANNER_STATE_PROLOG";
                case SCANNER_STATE_ROOT_ELEMENT: return "SCANNER_STATE_ROOT_ELEMENT";
                case SCANNER_STATE_CONTENT: return "SCANNER_STATE_CONTENT";
                case SCANNER_STATE_REFERENCE: return "SCANNER_STATE_REFERENCE";
                //case SCANNER_STATE_ATTRIBUTE_LIST: return "SCANNER_STATE_ATTRIBUTE_LIST";
                //case SCANNER_STATE_ATTRIBUTE_NAME: return "SCANNER_STATE_ATTRIBUTE_NAME";
                //case SCANNER_STATE_ATTRIBUTE_VALUE: return "SCANNER_STATE_ATTRIBUTE_VALUE";
                case SCANNER_STATE_TRAILING_MISC: return "SCANNER_STATE_TRAILING_MISC";
                case SCANNER_STATE_END_OF_INPUT: return "SCANNER_STATE_END_OF_INPUT";
                case SCANNER_STATE_TERMINATED: return "SCANNER_STATE_TERMINATED";
                case SCANNER_STATE_CDATA: return "SCANNER_STATE_CDATA";
                case SCANNER_STATE_TEXT_DECL: return "SCANNER_STATE_TEXT_DECL";
            }
        }

        return "??? ("+state+')';

    } // getScannerStateName(int):String

    /** Returns the dispatcher name. */
    public String getDispatcherName(Dispatcher dispatcher) {

        if (DEBUG_DISPATCHER) {
            if (dispatcher != null) {
                String name = dispatcher.getClass().getName();
                int index = name.lastIndexOf('.');
                if (index != -1) {
                    name = name.substring(index + 1);
                    index = name.lastIndexOf('$');
                    if (index != -1) {
                        name = name.substring(index + 1);
                    }
                }
                return name;
            }
        }
        return "null";

    } // getDispatcherName():String

    //
    // Classes
    //

    /**
     * Element stack. This stack operates without synchronization, error
     * checking, and it re-uses objects instead of throwing popped items
     * away.
     *
     * @author Andy Clark, IBM
     */
    protected static class ElementStack {

        //
        // Data
        //

        /** The stack data. */
        protected QName[] fElements;

        /** The size of the stack. */
        protected int fSize;

        //
        // Constructors
        //

        /** Default constructor. */
        public ElementStack() {
            fElements = new QName[10];
            for (int i = 0; i < fElements.length; i++) {
                fElements[i] = new QName();
            }
        } // <init>()

        //
        // Public methods
        //

        /** 
         * Pushes an element on the stack. 
         * <p>
         * <strong>Note:</strong> The QName values are copied into the
         * stack. In other words, the caller does <em>not</em> orphan
         * the element to the stack. Also, the QName object returned
         * is <em>not</em> orphaned to the caller. It should be 
         * considered read-only.
         *
         * @param element The element to push onto the stack.
         *
         * @return Returns the actual QName object that stores the
         */
        public QName pushElement(QName element) {
            if (fSize == fElements.length) {
                QName[] array = new QName[fElements.length * 2];
                System.arraycopy(fElements, 0, array, 0, fSize);
                fElements = array;
                for (int i = fSize; i < fElements.length; i++) {
                    fElements[i] = new QName();
                }
            }
            fElements[fSize].setValues(element);
            return fElements[fSize++];
        } // pushElement(QName):QName

        /** 
         * Pops an element off of the stack by setting the values of
         * the specified QName.
         * <p>
         * <strong>Note:</strong> The object returned is <em>not</em>
         * orphaned to the caller. Therefore, the caller should consider
         * the object to be read-only.
         */
        public void popElement(QName element) {
            element.setValues(fElements[--fSize]);
        } // popElement(QName)

        /** Clears the stack without throwing away existing QName objects. */
        public void clear() {
            fSize = 0;
        } // clear()

    } // class ElementStack

    /**
     * A stack for keeping track of entity offsets and lengths in
     * attribute values. This stack adds the attribute entities to
     * a specified XMLAttribute object.
     *
     * @author Andy Clark, IBM
     */
    protected static class AttrEntityStack {

        //
        // Data
        //

        /** Attributes. */
        protected XMLAttributes fAttributes;

        /** The index of the attribute where to add entities. */
        protected int fAttributeIndex;

        // stack information

        /** The size of the stack. */
        protected int fSize;

        /** The entity indexes on the stack. */
        protected int[] fEntityIndexes = new int[4];

        //
        // Public methods
        //

        /** 
         * Resets the attribute entity stack and sets the attributes
         * object to add entities to.
         *
         * @param attributes The attributes object where new attribute
         *                   entities are added.
         * @param attrIndex  The index of the attribute where to add
         *                   entities.
         */
        public void reset(XMLAttributes attributes, int attrIndex) {
            fAttributes = attributes;
            fAttributeIndex = attrIndex;
            fSize = 0;
        } // reset(XMLAttributes,int)

        /** Returns the size of the stack. */
        public int size() {
            return fSize;
        } // size():int

        /** 
         * Pushes a new entity onto the stack. 
         *
         * @param entityName   The entity name.
         * @param entityOffset The entity offset.
         */
        public void pushAttrEntity(String entityName, int entityOffset) {
            if (fSize == fEntityIndexes.length) {
                int[] indexarray = new int[fEntityIndexes.length * 2];
                System.arraycopy(fEntityIndexes, 0, indexarray, 0, fEntityIndexes.length);
                fEntityIndexes = indexarray;
            }
            fEntityIndexes[fSize] = 
                fAttributes.addAttributeEntity(fAttributeIndex, entityName, 
                                               entityOffset, -1);
            fSize++;
        } // pushAttrEntity(String,int)

        /**
         * Pops the current entity off of the stack and adds it to the
         * list of entities for the attribute in the XMLAttributes object.
         *
         * @param endOffset The entity's ending offset.
         */
        public void popAttrEntity(int endOffset) {
            fSize--;
            int entityIndex = fEntityIndexes[fSize];
            int offset = fAttributes.getEntityOffset(fAttributeIndex, entityIndex);
            int length = endOffset - offset;
            fAttributes.setEntityLength(fAttributeIndex, entityIndex, length);
        } // popAttrEntity(int)

    } // class AttrEntityStack

    /** 
     * This interface defines an XML "event" dispatching model. Classes
     * that implement this interface are responsible for scanning parts
     * of the XML document and dispatching callbacks.
     *
     * @author Glenn Marcy, IBM
     */
    protected interface Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException;

    } // interface Dispatcher

    /**
     * Dispatcher to handle XMLDecl scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class XMLDeclDispatcher 
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            // next dispatcher is prolog regardless of whether there
            // is an XMLDecl in this document
            setScannerState(SCANNER_STATE_PROLOG);
            setDispatcher(fPrologDispatcher);

            // scan XMLDecl
            try {
                if (fEntityScanner.skipString("<?xml")) {
                    fInMarkup = true;
                    // NOTE: special case where document starts with a PI
                    //       whose name starts with "xml" (e.g. "xmlfoo")
                    if (XMLChar.isName(fEntityScanner.peekChar())) {
                        fStringBuffer.clear();
                        fStringBuffer.append("xml");
                        while (XMLChar.isName(fEntityScanner.peekChar())) {
                            fStringBuffer.append((char)fEntityScanner.scanChar());
                        }
                        String target = fSymbolTable.addSymbol(fStringBuffer.ch, fStringBuffer.offset, fStringBuffer.length);
                        scanPIData(target, fString);
                    }

                    // standard XML declaration
                    else {
                        scanXMLDeclOrTextDecl(false);
                    }
                    return complete;
                }
            }

            // premature end of file
            catch (EOFException e) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "PrematureEOF",
                                           null,
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
                throw e;
            }

            // if no XMLDecl, then scan piece of prolog
            return true;

        } // dispatch(boolean):boolean

    } // class XMLDeclDispatcher

    /**
     * Dispatcher to handle prolog scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class PrologDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            try {
                boolean again;
                do {
                    again = false;
                    switch (fScannerState) {
                        case SCANNER_STATE_PROLOG: {
                            fEntityScanner.skipSpaces();
                            if (fEntityScanner.skipChar('<')) {
                                setScannerState(SCANNER_STATE_START_OF_MARKUP);
                                again = true;
                            }
                            else if (fEntityScanner.skipChar('&')) {
                                setScannerState(SCANNER_STATE_REFERENCE);
                                again = true;
                            }
                            else {
                                setScannerState(SCANNER_STATE_CONTENT);
                                again = true;
                            }
                            break;
                        }
                        case SCANNER_STATE_START_OF_MARKUP: {
                            fInMarkup = true;
                            if (fEntityScanner.skipChar('?')) {
                                setScannerState(SCANNER_STATE_PI);
                                again = true;
                            }
                            else if (fEntityScanner.skipChar('!')) {
                                if (fEntityScanner.skipChar('-')) {
                                    if (!fEntityScanner.skipChar('-')) {
                                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                                   "InvalidCommentStart",
                                                                   null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                    }
                                    setScannerState(SCANNER_STATE_COMMENT);
                                    again = true;
                                }
                                else if (fEntityScanner.skipString("DOCTYPE")) {
                                    setScannerState(SCANNER_STATE_DOCTYPE);
                                    again = true;
                                }
                                else {
                                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                               "MarkupNotRecognizedInProlog",
                                                               null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                }
                            }
                            else if (XMLChar.isNameStart(fEntityScanner.peekChar())) {
                                setScannerState(SCANNER_STATE_ROOT_ELEMENT);
                                setDispatcher(fContentDispatcher);
                                return true;
                            }
                            else {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                           "MarkupNotRecognizedInProlog",
                                                           null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            }
                            break;
                        }
                        case SCANNER_STATE_COMMENT: {
                            scanComment();
                            setScannerState(SCANNER_STATE_PROLOG);
                            break;  
                        }
                        case SCANNER_STATE_PI: {
                            scanPI();
                            setScannerState(SCANNER_STATE_PROLOG);
                            break;  
                        }
                        case SCANNER_STATE_DOCTYPE: {
                            if (fSeenDoctypeDecl) {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                           "AlreadySeenDoctype",
                                                           null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            }
                            fSeenDoctypeDecl = true;
                            scanDoctypeDecl();
                            setScannerState(SCANNER_STATE_PROLOG);
                            break;
                        }
                        case SCANNER_STATE_CONTENT: {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "ContentIllegalInProlog",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            fEntityScanner.scanChar();
                        }
                        case SCANNER_STATE_REFERENCE: {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "ReferenceIllegalInProlog",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                    }
                } while (complete || again);
    
                if (fEntityScanner.scanChar() != '<') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "RootElementRequired",
                                               null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                setScannerState(SCANNER_STATE_ROOT_ELEMENT);
                setDispatcher(fContentDispatcher);
            }

            // premature end of file
            catch (EOFException e) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "PrematureEOF",
                                           null,
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
                throw e;
            }

            return complete;

        } // dispatch(boolean):boolean

    } // class PrologDispatcher

    /**
     * Dispatcher to handle content scanning.
     *
     * @author Andy Clark, IBM
     * @author Eric Ye, IBM
     */
    protected final class ContentDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            try {
                boolean again;
                do {
                    again = false;
                    switch (fScannerState) {
                        case SCANNER_STATE_CONTENT: {
                            if (fEntityScanner.skipChar('<')) {
                                setScannerState(SCANNER_STATE_START_OF_MARKUP);
                                again = true;
                            }
                            else if (fEntityScanner.skipChar('&')) {
                                setScannerState(SCANNER_STATE_REFERENCE);
                                again = true;
                            }
                            else {
                                do {
                                    int c = scanContent();
                                    if (c == '<') {
                                        fInMarkup = true;
                                        fEntityScanner.scanChar();
                                        setScannerState(SCANNER_STATE_START_OF_MARKUP);
                                        break;
                                    }
                                    else if (c == '&') {
                                        fInMarkup = true;
                                        fEntityScanner.scanChar();
                                        setScannerState(SCANNER_STATE_REFERENCE);
                                        break;
                                    }
                                    /***
                                    else if (c == ']') {
                                        if (fEntityScanner.skipString("]]>")) {
                                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                                       "CDEndInContent",
                                                                       null,
                                                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                        }
                                    }
                                    /***/
                                    else if (c != -1 && XMLChar.isInvalid(c)) {
                                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, 
                                                                   "InvalidCharInContent",
                                                                   new Object[] {Integer.toString(c, 16)},
                                                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                        fEntityScanner.scanChar();
                                    }
                                } while (complete);
                            }
                            break;
                        }
                        case SCANNER_STATE_START_OF_MARKUP: {
                            fInMarkup = true;
                            if (fEntityScanner.skipChar('?')) {
                                setScannerState(SCANNER_STATE_PI);
                                again = true;
                            }
                            else if (fEntityScanner.skipChar('!')) {
                                if (fEntityScanner.skipChar('-')) {
                                    if (!fEntityScanner.skipChar('-')) {
                                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                                   "InvalidCommentStart",
                                                                   null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                    }
                                    setScannerState(SCANNER_STATE_COMMENT);
                                    again = true;
                                }
                                else if (fEntityScanner.skipString("[CDATA[")) {
                                    setScannerState(SCANNER_STATE_CDATA);
                                    again = true;
                                }
                                else if (fEntityScanner.skipString("DOCTYPE")) {
                                    setScannerState(SCANNER_STATE_DOCTYPE);
                                }
                                else {
                                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                               "MarkupNotRecognizedInContent",
                                                               null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                }
                            }
                            else if (fEntityScanner.skipChar('/')) {
                                if (scanEndElement() == 0) {
                                    setScannerState(SCANNER_STATE_TRAILING_MISC);
                                    setDispatcher(fTrailingMiscDispatcher);
                                    return complete;
                                }
                                setScannerState(SCANNER_STATE_CONTENT);
                            }
                            else if (XMLChar.isNameStart(fEntityScanner.peekChar())) {
                                scanStartElement();
                                setScannerState(SCANNER_STATE_CONTENT);
                            }
                            else {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                           "MarkupNotRecognizedInContent",
                                                           null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            }
                            break;
                        }
                        case SCANNER_STATE_COMMENT: {
                            scanComment();
                            setScannerState(SCANNER_STATE_CONTENT);
                            break;  
                        }
                        case SCANNER_STATE_PI: {
                            scanPI();
                            setScannerState(SCANNER_STATE_CONTENT);
                            break;  
                        }
                        case SCANNER_STATE_CDATA: {
                            scanCDATASection(complete);
                            setScannerState(SCANNER_STATE_CONTENT);
                            break;
                        }
                        case SCANNER_STATE_REFERENCE: {
                            fInMarkup = true;
                            // NOTE: We need to set the state beforehand
                            //       because the XMLEntityHandler#startEntity
                            //       callback could set the state to
                            //       SCANNER_STATE_TEXT_DECL and we don't want
                            //       to override that scanner state.
                            setScannerState(SCANNER_STATE_CONTENT);
                            if (fEntityScanner.skipChar('#')) {
                                scanCharReference();
                            }
                            else {
                                scanEntityReference();
                            }
                            break;
                        }
                        case SCANNER_STATE_TEXT_DECL: {
                            // scan text decl
                            if (fEntityScanner.skipString("<?xml")) {
                                fInMarkup = true;
                                // NOTE: special case where entity starts with a PI
                                //       whose name starts with "xml" (e.g. "xmlfoo")
                                if (XMLChar.isName(fEntityScanner.peekChar())) {
                                    fStringBuffer.clear();
                                    fStringBuffer.append("xml");
                                    while (XMLChar.isName(fEntityScanner.peekChar())) {
                                        fStringBuffer.append((char)fEntityScanner.scanChar());
                                    }
                                    String target = fSymbolTable.addSymbol(fStringBuffer.ch, fStringBuffer.offset, fStringBuffer.length);
                                    scanPIData(target, fString);
                                }
                
                                // standard text declaration
                                else {
                                    scanXMLDeclOrTextDecl(true);
                                }
                            }
                            setScannerState(SCANNER_STATE_CONTENT);
                            break;
                        }
                        case SCANNER_STATE_ROOT_ELEMENT: {
                            if (scanStartElement()) {
                                setScannerState(SCANNER_STATE_TRAILING_MISC);
                                setDispatcher(fTrailingMiscDispatcher);
                                return complete;
                            }
                            setScannerState(SCANNER_STATE_CONTENT);
                            break;
                        }
                        case SCANNER_STATE_DOCTYPE: {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "DoctypeIllegalInContent",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                    }
                } while (complete || again);
            }
    
            // premature end of file
            catch (EOFException e) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "PrematureEOF",
                                           null,
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
                throw e;
            }

            return complete;

        } // dispatch(boolean):boolean

    } // class ContentDispatcher

    /**
     * Dispatcher to handle trailing miscellaneous section scanning.
     *
     * @author Andy Clark, IBM
     * @author Eric Ye, IBM
     */
    protected final class TrailingMiscDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            try {
                boolean again;
                do {
                    again = false;
                    switch (fScannerState) {
                        case SCANNER_STATE_TRAILING_MISC: {
                            fEntityScanner.skipSpaces();
                            if (fEntityScanner.skipChar('<')) {
                                setScannerState(SCANNER_STATE_START_OF_MARKUP);
                                again = true;
                            }
                            else {
                                setScannerState(SCANNER_STATE_CONTENT);
                                again = true;
                            }
                            break;
                        }
                        case SCANNER_STATE_START_OF_MARKUP: {
                            fInMarkup = true;
                            if (fEntityScanner.skipChar('?')) {
                                setScannerState(SCANNER_STATE_PI);
                                again = true;
                            }
                            else if (fEntityScanner.skipChar('!')) {
                                setScannerState(SCANNER_STATE_COMMENT);
                                again = true;
                            }
                            break;
                        }
                        case SCANNER_STATE_PI: {
                            scanPI();
                            setScannerState(SCANNER_STATE_TRAILING_MISC);
                            break;
                        }
                        case SCANNER_STATE_COMMENT: {
                            if (!fEntityScanner.skipString("--")) {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                           "InvalidCommentStart",
                                                           null,
                                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            }
                            scanComment();
                            setScannerState(SCANNER_STATE_TRAILING_MISC);
                            break;
                        }
                        case SCANNER_STATE_CONTENT: {
                            int ch = fEntityScanner.peekChar();
                            if (ch == -1) {
                                setScannerState(SCANNER_STATE_TERMINATED);
                                return false;
                            }
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "ContentIllegalInTrailingMisc",
                                                       null,
                                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            fEntityScanner.scanChar();
                            setScannerState(SCANNER_STATE_TRAILING_MISC);
                            break;
                        }
                        case SCANNER_STATE_REFERENCE: {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "ReferenceIllegalInTrailingMisc",
                                                       null,
                                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            setScannerState(SCANNER_STATE_TRAILING_MISC);
                            break;
                        }
                    }
                } while (complete || again);
            }
            catch (EOFException e) {
                // NOTE: This is the only place we're allowed to reach
                //       the real end of the document stream. Unless the
                //       end of file was reached prematurely.
                if (fInMarkup) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "PrematureEOF",
                                               null,
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    throw e;
                }
            }

            setScannerState(SCANNER_STATE_TERMINATED);
            return false;

        } // dispatch(boolean):boolean

    } // class TrailingMiscDispatcher

} // class XMLDocumentScanner
