/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import java.io.EOFException;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Stack;

import org.apache.xerces.impl.XMLEntityManager;
import org.apache.xerces.impl.XMLEntityScanner;
import org.apache.xerces.impl.XMLErrorReporter;
import org.apache.xerces.impl.msg.XMLMessageFormatter;

import org.apache.xerces.util.XMLStringBuffer;
import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.XMLChar;

import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLAttributes;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLDocumentHandler;
import org.apache.xerces.xni.XMLDocumentSource;
import org.apache.xerces.xni.XMLString;

import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.helpers.NamespaceSupport;

/**
 * This class is responsible for scanning XML document structure
 * and content. The scanner acts as the source for the document
 * information which is communicated to the document handler.
 * <p>
 * This component requires the following features and properties from the
 * component manager that uses it:
 * <ul>
 *  <li>http://xml.org/sax/features/namespaces</li>
 *  <li>http://apache.org/xml/properties/internal/symbol-table</li>
 *  <li>http://apache.org/xml/properties/internal/error-reporter</li>
 *  <li>http://apache.org/xml/properties/internal/entity-manager</li>
 * </ul>
 *
 * @author Stubs generated by DesignDoc on Mon Sep 11 11:10:57 PDT 2000
 * @author Andy Clark, IBM
 *
 * @version $Id$
 */
public class XMLDocumentScanner
    extends XMLScanner
    implements XMLComponent, XMLDocumentSource, XMLEntityHandler {

    //
    // Constants
    //

    // scanner states

    /** Scanner state: XML declaration. */
    protected static final int SCANNER_STATE_XML_DECL = 0;

    /** Scanner state: start of markup. */
    protected static final int SCANNER_STATE_START_OF_MARKUP = 1;

    /** Scanner state: comment. */
    protected static final int SCANNER_STATE_COMMENT = 2;

    /** Scanner state: processing instruction. */
    protected static final int SCANNER_STATE_PI = 3;

    /** Scanner state: DOCTYPE. */
    protected static final int SCANNER_STATE_DOCTYPE = 4;

    /** Scanner state: prolog. */
    protected static final int SCANNER_STATE_PROLOG = 5;

    /** Scanner state: root element. */
    protected static final int SCANNER_STATE_ROOT_ELEMENT = 6;

    /** Scanner state: content. */
    protected static final int SCANNER_STATE_CONTENT = 7;

    /** Scanner state: reference. */
    protected static final int SCANNER_STATE_REFERENCE = 8;

    /** Scanner state: attribute list. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_LIST = 9;

    /** Scanner state: attribute name. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_NAME = 10;

    /** Scanner state: attribute value. */
    //protected static final int SCANNER_STATE_ATTRIBUTE_VALUE = 11;

    /** Scanner state: trailing misc. */
    protected static final int SCANNER_STATE_TRAILING_MISC = 12;

    /** Scanner state: end of input. */
    protected static final int SCANNER_STATE_END_OF_INPUT = 13;

    /** Scanner state: terminated. */
    protected static final int SCANNER_STATE_TERMINATED = 14;

    /** Scanner state: CDATA section. */
    protected static final int SCANNER_STATE_CDATA = 15;

    /** Scanner state: Text declaration. */
    protected static final int SCANNER_STATE_TEXT_DECL = 16;

    // debugging

    /** Debug scanner state. */
    private static final boolean DEBUG_SCANNER_STATE = false;

    /** Debug dispatcher. */
    private static final boolean DEBUG_DISPATCHER = false;

    /** Debug content dispatcher scanning. */
    private static final boolean DEBUG_CONTENT_SCANNING = false;

    //
    // Data
    //

    // properties

    /** DTD scanner. */
    protected XMLDTDScanner fDTDScanner;

    // protected data

    /** Document handler. */
    protected XMLDocumentHandler fDocumentHandler;

    /** Entity stack. */
    protected Stack fEntityStack = new Stack();

    /** Scanner state. */
    protected int fScannerState;

    /** Seen doctype declaration. */
    protected boolean fSeenDoctypeDecl;
    
    /** Standalone. */
    protected boolean fStandalone;

    /** Scanning attribute. */
    protected boolean fScanningAttribute;

    /** Scanning DTD. */
    protected boolean fScanningDTD;

    // element information

    /** Element depth. */
    protected int fElementDepth;

    /** Current element. */
    protected QName fCurrentElement;

    /** Element stack. */
    protected ElementStack fElementStack = new ElementStack();

    // features

    /** Namespaces. */
    protected boolean fNamespaces;

    // namespaces

    /** Namespace support. */
    protected NamespaceSupport fNamespaceSupport = new NamespaceSupport();

    // dispatchers

    /** Active dispatcher. */
    protected Dispatcher fDispatcher;

    /** XML declaration dispatcher. */
    protected Dispatcher fXMLDeclDispatcher = new XMLDeclDispatcher();

    /** Prolog dispatcher. */
    protected Dispatcher fPrologDispatcher = new PrologDispatcher();

    /** Content dispatcher. */
    protected Dispatcher fContentDispatcher = new ContentDispatcher();

    /** Trailing miscellaneous section dispatcher. */
    protected Dispatcher fTrailingMiscDispatcher = new TrailingMiscDispatcher();

    // private data

    /** Element QName. */
    private QName fElementQName = new QName();

    /** Attribute QName. */
    private QName fAttributeQName = new QName();

    /** Element attributes. */
    private XMLAttributes fAttributes = new XMLAttributes();

    /** Single character array. */
    private final char[] fSingleChar = new char[1];

    private String[] fPseudoAttributeValues = new String[3];

    /** External entity. */
    private XMLEntityManager.ExternalEntity fExternalEntity = new XMLEntityManager.ExternalEntity();

    // symbols

    /** Symbol: "amp". */
    private String fAmpSymbol;

    /** Symbol: "lt". */
    private String fLtSymbol;

    /** Symbol: "gt". */
    private String fGtSymbol;

    /** Symbol: "quot". */
    private String fQuotSymbol;

    /** Symbol: "apos". */
    private String fAposSymbol;

    /** Symbol: "xml". */
    private String fXmlSymbol;

    /** Symbol: "xmlns". */
    private String fXmlnsSymbol;

    //
    // Constructors
    //

    /** Default constructor. */
    public XMLDocumentScanner() {
    } // <init>()

    //
    // Public methods
    //

    /** 
     * Scans a document. 
     * <p>
     * <strong>Note:</strong> The caller of this method is responsible
     * for having called <code>reset(XMLComponentManager)</code> before
     * any scanning and having initialized the entity manager by starting 
     * the document entity.
     *
     * @param complete True to completely scan the rest of the document.
     *
     * @returns True if scanning is not finished.
     */
    public boolean scanDocument(boolean complete) 
        throws IOException, SAXException {

        // keep dispatching "events"
        do {
            if (!fDispatcher.dispatch(complete)) {
                return false;
            }
        } while (complete);

        // return success
        return true;

    } // scanDocument(boolean):boolean

    //
    // XMLComponent methods
    //

    /**
     * 
     * 
     * @param componentManager The component manager.
     *
     * @throws SAXException Throws exception if required features and
     *                      properties cannot be found.
     */
    public void reset(XMLComponentManager componentManager)
        throws SAXException {

        super.reset(componentManager);

        // sax features
        final String NAMESPACES = Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
        fNamespaces = componentManager.getFeature(NAMESPACES);
        fAttributes.setNamespaces(fNamespaces);

        // xerces properties
        final String DTD_SCANNER = Constants.XERCES_PROPERTY_PREFIX + Constants.DTD_SCANNER_PROPERTY;
        fDTDScanner = (XMLDTDScanner)componentManager.getProperty(DTD_SCANNER);

        // initialize vars
        fEntityStack.removeAllElements();
        fNamespaceSupport.reset();

        fElementDepth = 0;
        fCurrentElement = null;
        fElementStack.clear();
        
        fSeenDoctypeDecl = false;
        fStandalone = false;
        fScanningDTD = false;

        // save built-in entity names
        fAmpSymbol = fSymbolTable.addSymbol("amp");
        fLtSymbol = fSymbolTable.addSymbol("lt");
        fGtSymbol = fSymbolTable.addSymbol("gt");
        fQuotSymbol = fSymbolTable.addSymbol("quot");
        fAposSymbol = fSymbolTable.addSymbol("apos");
        fXmlSymbol = fSymbolTable.addSymbol("xml");
        fXmlnsSymbol = fSymbolTable.addSymbol("xmlns");

        // setup dispatcher
        setScannerState(SCANNER_STATE_XML_DECL);
        setDispatcher(fXMLDeclDispatcher);
        
    } // reset(XMLComponentManager)

    /**
     * Sets the state of a feature during parsing.
     * 
     * @param featureId 
     * @param state 
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setFeature(String,boolean)

    /**
     * Sets the value of a property during parsing.
     * 
     * @param propertyId 
     * @param value 
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {
        
        super.setProperty(propertyId, value);

        // Xerces properties
        if (propertyId.startsWith(Constants.XERCES_PROPERTY_PREFIX)) {
            String property = propertyId.substring(Constants.XERCES_PROPERTY_PREFIX.length());
            if (property.equals(Constants.DTD_SCANNER_PROPERTY)) {
                fDTDScanner = (XMLDTDScanner)value;
            }
            else if (property.equals(Constants.ENTITY_MANAGER_PROPERTY)) {
                fEntityManager = (XMLEntityManager)value;
            }
            return;
        }

    } // setProperty(String,Object)

    //
    // XMLDocumentSource methods
    //

    /**
     * setDocumentHandler
     * 
     * @param documentHandler 
     */
    public void setDocumentHandler(XMLDocumentHandler documentHandler) {
        fDocumentHandler = documentHandler;
    } // setDocumentHandler(XMLDocumentHandler)

    //
    // XMLEntityHandler methods
    //

    /**
     * This method notifies of the start of an entity. The document entity
     * has the pseudo-name of "[xml]"; the DTD has the pseudo-name of "[dtd]; 
     * parameter entity names start with '%'; and general entities are just
     * specified by their name.
     * 
     * @param name     The name of the entity.
     * @param publicId The public identifier of the entity if the entity
     *                 is external, null otherwise.
     * @param systemId The system identifier of the entity if the entity
     *                 is external, null otherwise.
     * @param encoding The auto-detected IANA encoding name of the entity
     *                 stream. This value will be null in those situations
     *                 where the entity encoding is not auto-detected (e.g.
     *                 internal entities or a document entity that is
     *                 parsed from a java.io.Reader).
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void startEntity(String name, String publicId, String systemId,
                            String encoding) throws SAXException {

        // keep track of this entity
        Entity entity = new Entity(name, publicId, systemId, fElementDepth);
        fEntityStack.push(entity);

        // prepare to look for a TextDecl if external general entity
        if (!name.equals("[xml]") && fEntityScanner.isExternal()) {
            setScannerState(SCANNER_STATE_TEXT_DECL);
        }

        // call handler
        if (fDocumentHandler != null) {
            if (!fScanningAttribute) {
                fDocumentHandler.startEntity(name, publicId, systemId, encoding);
            }
            if (name.equals("[xml]")) {
                fDocumentHandler.startDocument();
            }
        }

    } // startEntity(String,String,String,String)

    /**
     * This method notifies the end of an entity. The document entity has
     * the pseudo-name of "[xml]"; the DTD has the pseudo-name of "[dtd]; 
     * parameter entity names start with '%'; and general entities are just
     * specified by their name.
     * 
     * @param name The name of the entity.
     *
     * @throws SAXException Thrown by handler to signal an error.
     */
    public void endEntity(String name) throws SAXException {

        // sanity check
        Entity entity = (Entity)fEntityStack.pop();
        if (!name.equals(entity.name)) {
            // REVISIT: report error
            throw new SAXException("internal error: startEntity(\""+entity.name+"\") "+
                                   "doesn't match endEntity(\""+name+"\")");
        }

        // check for un-balanced entity content
        // 1) state isn't set back to SCANNER_STATE_CONTENT
        /***
        // REVISIT: Put these checks back and verify that this is the
        //          right way to detect and signal these errors. -Ac
        if (fScannerState != SCANNER_STATE_CONTENT) {
            switch (fScannerState) {
                case SCANNER_STATE_COMMENT: {
                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, "COMMENT_NOT_IN_ONE_ENTITY",
                                                null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                case SCANNER_STATE_PI: {
                    fErrorReporter.reportError( XMLMessageFormatter.XML_DOMAIN, "PI_NOT_IN_ONE_ENTITY",
                                                null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                default: {
                    // REVISIT: report error
                    throw new SAXException("internal error: at end of entity, state should be CONTENT, not "+fScannerState);
                }
            }
        }
        /***/

        // if we got a start/end external entity, then we need to
        // stop looking for a text declaration
        if (fScannerState == SCANNER_STATE_TEXT_DECL) {
            setScannerState(SCANNER_STATE_CONTENT);
        }

        // 2) scanner markup depth isn't what it was at the start of
        //    the entity
        if (fElementDepth != entity.elementDepth) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, "ElementEntityMismatch", 
                                       new Object[]{fCurrentElement.rawname}, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // call handler
        if (fDocumentHandler != null) {
            if (name.equals("[xml]")) {
                fDocumentHandler.endDocument();
            }
            if (!fScanningAttribute) {
                fDocumentHandler.endEntity(name);
            }
        }
        
    } // endEntity(String)

    //
    // Protected methods
    //

    // scanning methods

    /**
     * Scans an XML or text declaration.
     * <p>
     * <pre>
     * [23] XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S? '?>'
     * [24] VersionInfo ::= S 'version' Eq (' VersionNum ' | " VersionNum ")
     * [80] EncodingDecl ::= S 'encoding' Eq ('"' EncName '"' |  "'" EncName "'" )
     * [81] EncName ::= [A-Za-z] ([A-Za-z0-9._] | '-')*
     * [32] SDDecl ::= S 'standalone' Eq (("'" ('yes' | 'no') "'")
     *                 | ('"' ('yes' | 'no') '"'))
     *
     * [77] TextDecl ::= '<?xml' VersionInfo? EncodingDecl S? '?>'
     * </pre>
     *
     * @param scanningTextDecl True if a text declaration is to
     *                         be scanned instead of an XML
     *                         declaration.
     */
    protected void scanXMLDeclOrTextDecl(boolean scanningTextDecl) 
        throws IOException, SAXException {

        // pseudo-attribute values
        String version = null;
        String encoding = null;
        String standalone = null;

        super.scanXMLDeclOrTextDecl(scanningTextDecl, fPseudoAttributeValues);

        version = fPseudoAttributeValues[0];
        encoding = fPseudoAttributeValues[1];
        standalone = fPseudoAttributeValues[2];

        fStandalone = standalone != null && standalone.equals("yes");
        fEntityManager.setStandalone(fStandalone);

        // call handler
        if (fDocumentHandler != null) {
            if (scanningTextDecl) {
                fDocumentHandler.textDecl(version, encoding);
            }
            else {
                fDocumentHandler.xmlDecl(version, encoding, standalone);
            }
        }

    } // scanXMLDeclOrTextDecl(boolean)

    /**
     * Scans a processing data. This is needed to handle the situation
     * where a document starts with a processing instruction whose 
     * target name <em>starts with</em> "xml". (e.g. xmlfoo)
     *
     * @param target The PI target
     * @param data The string to fill in with the data
     */
    protected void scanPIData(String target, XMLString data) 
        throws IOException, SAXException {

        super.scanPIData(target, data);

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.processingInstruction(target, data);
        }

    } // scanPIData(String)

    /**
     * Scans a comment.
     * <p>
     * <pre>
     * [15] Comment ::= '&lt!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
     * </pre>
     * <p>
     * <strong>Note:</strong> Called after scanning past '&lt;!--'
     */
    protected void scanComment() throws IOException, SAXException {

        scanComment(fStringBuffer);

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.comment(fStringBuffer);
        }

    } // scanComment()
    
    /** Scans a doctype declaration. */
    protected void scanDoctypeDecl() throws IOException, SAXException {

        // spaces
        if (!fEntityScanner.skipSpaces()) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // root element name
        String name = fEntityScanner.scanName();
        if (name == null) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "MSG_ROOT_ELEMENT_TYPE_REQUIRED",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // external id
        String systemId = null;
        String publicId = null;
        boolean spaces = fEntityScanner.skipSpaces();
        if (spaces) {
            if (fEntityScanner.skipString("SYSTEM")) {
                if (!fEntityScanner.skipSpaces()) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SpaceRequiredAfterSYSTEM",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                int quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "QuoteRequiredInSystemID",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                fEntityScanner.scanChar();
                // REVISIT: do right
                XMLString value = fString;
                if (fEntityScanner.scanLiteral(quote, fString) != quote) {
                    fStringBuffer.clear();
                    do {
                        fStringBuffer.append(fString);
                    } while (fEntityScanner.scanLiteral(quote, fString) != quote);
                    fStringBuffer.append(fString);
                    value = fStringBuffer;
                }
                systemId = value.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SystemIDUnterminated",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
            }
            else if (fEntityScanner.skipString("PUBLIC")) {
                if (!fEntityScanner.skipSpaces()) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                             "SpaceRequiredAfterPUBLIC",
                             null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                int quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "QuoteRequiredInPublicID",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                fEntityScanner.scanChar();
                // REVISIT: do right
                XMLString value = fString;
                if (fEntityScanner.scanLiteral(quote, fString) != quote) {
                    fStringBuffer.clear();
                    do {
                        fStringBuffer.append(fString);
                    } while (fEntityScanner.scanLiteral(quote, fString) != quote);
                    fStringBuffer.append(fString);
                    value = fStringBuffer;
                }
                publicId = value.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "PublicIDUnterminated",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                if (!fEntityScanner.skipSpaces()) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SpaceRequiredBetweenPublicAndSystem",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                quote = fEntityScanner.peekChar();
                if (quote != '\'' && quote != '"') {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "QuoteRequiredInSystemID",
                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                fEntityScanner.scanChar();
                // REVISIT: do right
                value = fString;
                if (fEntityScanner.scanLiteral(quote, fString) != quote) {
                    fStringBuffer.clear();
                    do {
                        fStringBuffer.append(fString);
                    } while (fEntityScanner.scanLiteral(quote, fString) != quote);
                    fStringBuffer.append(fString);
                    value = fStringBuffer;
                }
                systemId = value.toString();
                if (!fEntityScanner.skipChar(quote)) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "SystemIDUnterminated",
                                               null, 
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
            }
            fEntityScanner.skipSpaces();
        }

        // internal subset
        if (fEntityScanner.skipChar('[')) {
            fEntityManager.setEntityHandler(fDTDScanner);
            final boolean complete = true;
            final boolean hasExternalDTD = systemId != null;
            fDTDScanner.scanDTDInternalSubset(complete, fStandalone, hasExternalDTD);
            fEntityManager.setEntityHandler(this);
            // REVISIT: Do we need to emit an error here? We can usually
            //          assume that it will be consumed by the DTD scanner
            //          or else the DTD scanner will fail on seeing the
            //          document content. However, there is the continue-
            //          after-fatal-error setting... -Ac
            if (!fEntityScanner.skipChar(']')) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "EXPECTED_SQUARE_BRACKET_TO_CLOSE_INTERNAL_SUBSET",
                                           null,
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }
            fEntityScanner.skipSpaces();
        }

        // end
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('>')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "DoctypedeclUnterminated",
                                       new Object[]{name},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.doctypeDecl(name, publicId, systemId);
        }

        // external subset
        if (systemId != null) {
            XMLInputSource xmlInputSource = 
                fEntityManager.resolveEntity(publicId, systemId, null);
            fEntityManager.setEntityHandler(fDTDScanner);
            fEntityManager.startDTDEntity(xmlInputSource);
            final boolean complete = true;
            fDTDScanner.scanDTD(complete);
            fEntityManager.setEntityHandler(this);
        }

        // external subset
        // TODO: scan external subset

    } // scanDoctypeDecl()

    /** 
     * Scans a start element. This method will handle the binding of
     * namespace information and notifying the handler of the start
     * of the element.
     * <p>
     * <pre>
     * [44] EmptyElemTag ::= '&lt;' Name (S Attribute)* S? '/>'
     * [40] STag ::= '&lt;' Name (S Attribute)* S? '>'
     * </pre> 
     * <p>
     * <strong>Note:</strong> This method assumes that the leading
     * '&lt;' character has been consumed.
     * <p>
     * <strong>Note:</strong> This method uses the fElementQName and
     * fAttributes variables. The contents of these variables will be
     * destroyed. The caller should copy important information out of
     * these variables before calling this method.
     *
     * @returns True if element is empty. (i.e. It matches
     *          production [44].
     */
    protected boolean scanStartElement() 
        throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanStartElement()");

        // increase depth
        fElementDepth++;

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fElementQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fElementQName.setValues(null, name, name, null);
        }
        String rawname = fElementQName.rawname;

        // attributes
        boolean empty = false;
        fAttributes.clear();
        do {
            // spaces
            fEntityScanner.skipSpaces();

            // end tag?
            int c = fEntityScanner.peekChar();
            if (c == '>') {
                fEntityScanner.scanChar();
                break;
            }
            else if (c == '/') {
                fEntityScanner.scanChar();
                if (!fEntityScanner.skipChar('>')) {
                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                               "ElementUnterminated",
                                               new Object[]{rawname},
                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                }
                empty = true;
                break;
            }
            else if (!XMLChar.isNameStart(c)) {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "ElementUnterminated",
                                           new Object[]{rawname},
                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
            }

            // attributes
            scanAttribute(fAttributes);

        } while (true);

        // bind namespaces
        if (fNamespaces) {
            bindNamespaces(fElementQName, fAttributes);
        }

        // push element stack
        fCurrentElement = fElementStack.pushElement(fElementQName);

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.startElement(fElementQName, fAttributes);
            if (empty) {
                handleEndElement(fElementQName);
            }
        }

        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanStartElement(): "+empty);
        return empty;

    } // scanStartElement():boolean

    /** 
     * Scans an attribute.
     * <p>
     * <pre>
     * [41] Attribute ::= Name Eq AttValue
     * [10] AttValue ::= '"' ([^<&"] | Reference)* '"' | "'" ([^<&'] | Reference)* "'"
     * </pre> 
     * <p>
     * <strong>Note:</strong> This method assumes that the next 
     * character on the stream is the first character of the attribute
     * name.
     *
     * @param attributes The attributes list for the scanned attribute.
     */
    protected void scanAttribute(XMLAttributes attributes) 
        throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanAttribute()");

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fAttributeQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fAttributeQName.setValues(null, name, name, null);
        }

        // equals
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('=')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "EqRequiredInAttribute",
                                       new Object[]{fCurrentElement.rawname, fAttributeQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fEntityScanner.skipSpaces();

        // quote
        int quote = fEntityScanner.peekChar();
        if (quote != '\'' && quote != '"') {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "OpenQuoteExpected",
                                       new Object[]{fAttributeQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }
        fEntityScanner.scanChar();

        // content
        final String CDATA = fSymbolTable.addSymbol("CDATA");
        attributes.setAttribute(fAttributeQName, CDATA, null);
        XMLString value = fString;
        if (fEntityScanner.scanLiteral(quote, fString) != quote) {
            fStringBuffer.clear();
            do {
                fStringBuffer.append(fString);
                /***
                if (fEntityScanner.peekChar() == '&') {
                    // TODO: handle entities in value
                }
                /***/
            } while (fEntityScanner.scanLiteral(quote, fString) != quote);
            fStringBuffer.append(fString);
            value = fStringBuffer;
        }
        attributes.setValue(attributes.getLength() - 1, value);

        // quote
        int cquote = fEntityScanner.scanChar();
        if (cquote != cquote) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "CloseQuoteExpected",
                                       new Object[]{fAttributeQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanAttribute()");
    } // scanAttribute(XMLAttributes)

    /**
     * Scans content.
     *
     * @returns Returns the next character on the stream.
     */
    protected int scanContent() throws IOException, SAXException {

        int c = fEntityScanner.scanContent(fString);
        if (fDocumentHandler != null && fString.length > 0) {
            fDocumentHandler.characters(fString);
        }
        return c;

    } // scanContent():int

    /**
     * Scans a CDATA section.
     *
     * @returns True if CDATA section is complete.
     */
    protected boolean scanCDATASection(boolean complete) 
        throws IOException, SAXException {
        throw new SAXException("not implemented");
    } // scanCDATASection(boolean):boolean

    /**
     * Scans an end element.
     * <p>
     * <pre>
     * [42] ETag ::= '&lt;/' Name S? '>'
     * </pre>
     * <p>
     * <strong>Note:</strong> This method uses the fElementQName variable.
     * The contents of this variable will be destroyed. The caller should
     * copy the needed information out of this variable before calling
     * this method.
     *
     * @returns The element depth.
     */
    protected int scanEndElement() throws IOException, SAXException {
        if (DEBUG_CONTENT_SCANNING) System.out.println(">>> scanEndElement()");

        // name
        if (fNamespaces) {
            fEntityScanner.scanQName(fElementQName);
        }
        else {
            String name = fEntityScanner.scanName();
            fElementQName.setValues(null, name, name, null);
        }

        // end
        fEntityScanner.skipSpaces();
        if (!fEntityScanner.skipChar('>')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "ETagUnterminated",
                                       new Object[]{fElementQName.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // handle end element
        int depth = handleEndElement(fElementQName);
        if (DEBUG_CONTENT_SCANNING) System.out.println("<<< scanEndElement(): "+depth);
        return depth;

    } // scanEndElement():int

    /**
     * Scans a character reference.
     * <p>
     * <pre>
     * [66] CharRef ::= '&#' [0-9]+ ';' | '&#x' [0-9a-fA-F]+ ';'
     * </pre>
     */
    protected void scanCharReference() 
        throws IOException, SAXException {

        int value = scanCharReferenceValue();

        // call handler
        if (fDocumentHandler != null) {
            fSingleChar[0] = (char)value;
            fString.setValues(fSingleChar, 0, 1);
            fDocumentHandler.characters(fString);
        }

    } // scanCharReference()

    /**
     * Scans an entity reference.
     *
     * @throws IOException  Thrown if i/o error occurs.
     * @throws SAXException Thrown if handler throws exception upon
     *                      notification.
     */
    protected void scanEntityReference() throws IOException, SAXException {

        // name
        String name = fEntityScanner.scanName();
        if (name == null) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "NameRequiredInReference",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // end
        if (!fEntityScanner.skipChar(';')) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "SemicolonRequiredInReference",
                                       null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // handle built-in entities
        if (name == fAmpSymbol) {
            handleCharacter('&');
        }
        else if (name == fLtSymbol) {
            handleCharacter('<');
        }
        else if (name == fGtSymbol) {
            handleCharacter('>');
        }
        else if (name == fQuotSymbol) {
            handleCharacter('"');
        }
        else if (name == fAposSymbol) {
            handleCharacter('\'');
        }
        
        // start general entity
        else {
            fEntityManager.startEntity(name, false);
        }

    } // scanEntityReference()

    // utility methods

    /** 
     * Calls document handler with a single character. 
     *
     * @param c
     */
    protected void handleCharacter(char c) throws SAXException {
        if (fDocumentHandler != null) {
            fSingleChar[0] = c;
            fString.setValues(fSingleChar, 0, 1);
            fDocumentHandler.characters(fString);
        }
    } // handleCharacter(char)

    /**
     * Binds the namespaces. This method will handle calling the
     * document handler to start the prefix mappings.
     * <p>
     * <strong>Note:</strong> This method makes use of the
     * fAttributeQName variable. Any contents of the variable will
     * be destroyed. Caller should copy the values out of this
     * temporary variable before calling this method.
     *
     * @param element    The element name.
     * @param attributes The attributes for the element.
     *
     * @throws SAXException Thrown if handler throws SAX exception upon
     *                      notification of start prefix mapping.
     */
    protected void bindNamespaces(QName element, XMLAttributes attributes)
        throws SAXException {

        // add new namespace context
        fNamespaceSupport.pushContext();

        // search for new namespace bindings
        int length = attributes.getLength();
        for (int i = 0; i < length; i++) {
            String rawname = attributes.getQName(i);
            if (rawname.startsWith("xmlns")) {
                // declare prefix in context
                String prefix = rawname.length() > 5
                              ? attributes.getLocalName(i) : "";
                String uri = attributes.getValue(i);
                fNamespaceSupport.declarePrefix(prefix, uri);

                // call handler
                if (fDocumentHandler != null) {
                    fDocumentHandler.startPrefixMapping(prefix, uri);
                }
            }
        }

        // bind the element
        String prefix = element.prefix != null
                      ? element.prefix : "";
        element.uri = fNamespaceSupport.getURI(prefix);
        if (element.prefix == null && element.uri != null) {
            element.prefix = fSymbolTable.addSymbol("");
        }
        if (element.prefix != null && element.uri == null) {
            fErrorReporter.reportError(XMLMessageFormatter.XMLNS_DOMAIN,
                                       "ElementPrefixUnbound",
                                       new Object[]{element.prefix, element.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // bind the attributes
        for (int i = 0; i < length; i++) {
            attributes.getName(i, fAttributeQName);
            String arawname = fAttributeQName.rawname;
            String aprefix = fAttributeQName.prefix != null 
                           ? fAttributeQName.prefix : "";
            if (aprefix == fXmlSymbol) {
                fAttributeQName.uri = NamespaceSupport.XMLNS;
                attributes.setName(i, fAttributeQName);
            }
            else if (arawname != fXmlnsSymbol && !arawname.startsWith("xmlns:")) {
                if (fAttributeQName.prefix != null) {
                    fAttributeQName.uri = fNamespaceSupport.getURI(fAttributeQName.prefix);
                    if (fAttributeQName.uri == null) {
                        fErrorReporter.reportError(XMLMessageFormatter.XMLNS_DOMAIN,
                                                   "AttributePrefixUnbound",
                                                   new Object[]{fAttributeQName.prefix, fAttributeQName.rawname},
                                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    }
                }
                else {
                    // attributes with no prefix get element's uri
                    fAttributeQName.uri = element.uri;
                }
                attributes.setName(i, fAttributeQName);
            }
        }

    } // bindNamespaces(QName,XMLAttributes)

    /** 
     * Handles the end element. This method will make sure that
     * the end element name matches the current element and notify
     * the handler about the end of the element and the end of any
     * relevent prefix mappings.
     *
     * @param element The element.
     *
     * @returns The element depth.
     *
     * @throws SAXException Thrown if the handler throws a SAX exception
     *                      upon notification.
     */
    protected int handleEndElement(QName element) throws SAXException {

        // make sure the elements match
        QName startElement = fElementQName;
        fElementStack.popElement(startElement);
        if (element.rawname != startElement.rawname) {
            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                       "ETagRequired",
                                       new Object[]{startElement.rawname},
                                       XMLErrorReporter.SEVERITY_FATAL_ERROR);
        }

        // bind namespaces
        if (fNamespaces) {
            element.uri = startElement.uri;
        }
        
        // decrease depth
        fElementDepth--;

        // call handler
        if (fDocumentHandler != null) {
            fDocumentHandler.endElement(element);
        }

        // end prefix mappings
        if (fNamespaces) {
            // call handler
            if (fDocumentHandler != null) {
                Enumeration prefixes = fNamespaceSupport.getDeclaredPrefixes();
                while (prefixes.hasMoreElements()) {
                    String prefix = (String)prefixes.nextElement();
                    fDocumentHandler.endPrefixMapping(prefix);
                }
            }

            // pop context
            fNamespaceSupport.popContext();
        }

        return fElementDepth;

    } // callEndElement(QName):int

    // helper methods

    /**
     * Sets the scanner state.
     *
     * @param state The new scanner state.
     */
    protected final void setScannerState(int state) {

        fScannerState = state;
        if (DEBUG_SCANNER_STATE) {
            System.out.print("### setScannerState: ");
            System.out.print(getScannerStateName(state));
            System.out.println();
        }

    } // setScannerState(int)

    /**
     * Sets the dispatcher.
     *
     * @param dispatcher The new dispatcher.
     */
    protected final void setDispatcher(Dispatcher dispatcher) {
        fDispatcher = dispatcher;
        if (DEBUG_DISPATCHER) {
            System.out.print("%%% setDispatcher: ");
            System.out.print(getDispatcherName(dispatcher));
            System.out.println();
        }
    }

    //
    // Private methods
    //

    /** Returns the scanner state name. */
    private static String getScannerStateName(int state) {

        if (DEBUG_SCANNER_STATE) {
            switch (state) {
                case SCANNER_STATE_XML_DECL: return "SCANNER_STATE_XML_DECL";
                case SCANNER_STATE_START_OF_MARKUP: return "SCANNER_STATE_START_OF_MARKUP";
                case SCANNER_STATE_COMMENT: return "SCANNER_STATE_COMMENT";
                case SCANNER_STATE_PI: return "SCANNER_STATE_PI";
                case SCANNER_STATE_DOCTYPE: return "SCANNER_STATE_DOCTYPE";
                case SCANNER_STATE_PROLOG: return "SCANNER_STATE_PROLOG";
                case SCANNER_STATE_ROOT_ELEMENT: return "SCANNER_STATE_ROOT_ELEMENT";
                case SCANNER_STATE_CONTENT: return "SCANNER_STATE_CONTENT";
                case SCANNER_STATE_REFERENCE: return "SCANNER_STATE_REFERENCE";
                //case SCANNER_STATE_ATTRIBUTE_LIST: return "SCANNER_STATE_ATTRIBUTE_LIST";
                //case SCANNER_STATE_ATTRIBUTE_NAME: return "SCANNER_STATE_ATTRIBUTE_NAME";
                //case SCANNER_STATE_ATTRIBUTE_VALUE: return "SCANNER_STATE_ATTRIBUTE_VALUE";
                case SCANNER_STATE_TRAILING_MISC: return "SCANNER_STATE_TRAILING_MISC";
                case SCANNER_STATE_END_OF_INPUT: return "SCANNER_STATE_END_OF_INPUT";
                case SCANNER_STATE_TERMINATED: return "SCANNER_STATE_TERMINATED";
                case SCANNER_STATE_CDATA: return "SCANNER_STATE_CDATA";
                case SCANNER_STATE_TEXT_DECL: return "SCANNER_STATE_TEXT_DECL";
            }
        }

        return "??? ("+state+')';

    } // getScannerStateName(int):String

    /** Returns the dispatcher name. */
    public String getDispatcherName(Dispatcher dispatcher) {

        if (DEBUG_DISPATCHER) {
            if (dispatcher != null) {
                String name = dispatcher.getClass().getName();
                int index = name.lastIndexOf('.');
                if (index != -1) {
                    name = name.substring(index + 1);
                    index = name.lastIndexOf('$');
                    if (index != -1) {
                        name = name.substring(index + 1);
                    }
                }
                return name;
            }
        }
        return "null";

    } // getDispatcherName():String

    //
    // Classes
    //

    /**
     * Element stack. This stack operates without synchronization, error
     * checking, and it re-uses objects instead of throwing popped items
     * away.
     *
     * @author Andy Clark, IBM
     */
    protected static class ElementStack {

        //
        // Data
        //

        /** The stack data. */
        protected QName[] fElements;

        /** The size of the stack. */
        protected int fSize;

        //
        // Constructors
        //

        /** Default constructor. */
        public ElementStack() {
            fElements = new QName[10];
            for (int i = 0; i < fElements.length; i++) {
                fElements[i] = new QName();
            }
        } // <init>()

        //
        // Public methods
        //

        /** 
         * Pushes an element on the stack. 
         * <p>
         * <strong>Note:</strong> The QName values are copied into the
         * stack. In other words, the caller does <em>not</em> orphan
         * the element to the stack. Also, the QName object returned
         * is <em>not</em> orphaned to the caller. It should be 
         * considered read-only.
         *
         * @param element The element to push onto the stack.
         *
         * @return Returns the actual QName object that stores the
         */
        public QName pushElement(QName element) {
            if (fSize == fElements.length) {
                QName[] array = new QName[fElements.length * 2];
                System.arraycopy(fElements, 0, array, 0, fSize);
                fElements = array;
                for (int i = fSize; i < fElements.length; i++) {
                    fElements[i] = new QName();
                }
            }
            fElements[fSize].setValues(element);
            return fElements[fSize++];
        } // pushElement(QName):QName

        /** 
         * Pops an element off of the stack by setting the values of
         * the specified QName.
         * <p>
         * <strong>Note:</strong> The object returned is <em>not</em>
         * orphaned to the caller. Therefore, the caller should consider
         * the object to be read-only.
         */
        public void popElement(QName element) {
            element.setValues(fElements[--fSize]);
        } // popElement(QName)

        /** Clears the stack without throwing away existing QName objects. */
        public void clear() {
            fSize = 0;
        }

    } // class ElementStack

    /**
     * Entity for entity stack. 
     * <p>
     * <strong>Note:</strong> The fields in this class are public but should
     * only be set at construction time (or at the time when it is pushed
     * onto the entity stack). In other words, once pushed onto the entity
     * stack, the entity information is considered read-only.
     *
     * @author Andy Clark, IBM
     */
    protected static class Entity {

        //
        // Data
        //

        /** Entity name. */
        public String name;

        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Element depth. */
        public int elementDepth;

        //
        // Constructors
        //

        /** Constructs an entity. */
        public Entity(String name, String publicId, String systemId, 
                      int elementDepth) {
            setValues(name, publicId, systemId, elementDepth);
        } // <init>(String,String,String,int)

        //
        // Public methods
        //

        /** Clears the structure. */
        public void clear() {
            name = null;
            publicId = null;
            systemId = null;
            elementDepth = -1;
        } // clear()

        /**
         * Sets the values of this structure.
         *
         * @param name         The name.
         * @param publicId     The public identifier.
         * @param systemId     The system identifier.
         * @param elementDepth The element depth.
         */
        public void setValues(String name, String publicId, String systemid,
                              int elementDepth) {
            this.name = name;
            this.publicId = publicId;
            this.systemId = systemId;
            this.elementDepth = elementDepth;
        } // setValues(String,String,String,int)

        //
        // Object methods
        //

        /** Returns a string representation of this object. */
        public String toString() {

            StringBuffer str = new StringBuffer();
            boolean comma = false;
            if (name != null) {
                str.append("name=\"");
                str.append(name);
                str.append('"');
                comma = true;
            }
            if (publicId != null) {
                if (comma) {
                    str.append(',');
                }
                str.append("publicId=\"");
                str.append(publicId);
                str.append('"');
                comma = true;
            }
            if (systemId != null) {
                if (comma) {
                    str.append(',');
                }
                str.append("systemId=\"");
                str.append(systemId);
                str.append('"');
                comma = true;
            }
            if (elementDepth != -1) {
                if (comma) {
                    str.append(',');
                }
                str.append("elementDepth=");
                str.append(elementDepth);
            }
            return str.toString();

        } // toString():String

    } // class Entity

    /** 
     * This interface defines an XML "event" dispatching model. Classes
     * that implement this interface are responsible for scanning parts
     * of the XML document and dispatching callbacks.
     *
     * @author Glenn Marcy, IBM
     */
    protected interface Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException;

    } // interface Dispatcher

    /**
     * Dispatcher to handle XMLDecl scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class XMLDeclDispatcher 
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            // next dispatcher is prolog regardless of whether there
            // is an XMLDecl in this document
            setScannerState(SCANNER_STATE_PROLOG);
            setDispatcher(fPrologDispatcher);

            // scan XMLDecl
            if (fEntityScanner.skipString("<?xml")) {
                // NOTE: special case where document starts with a PI
                //       whose name starts with "xml" (e.g. "xmlfoo")
                if (XMLChar.isName(fEntityScanner.peekChar())) {
                    fStringBuffer.clear();
                    fStringBuffer.append("xml");
                    while (XMLChar.isName(fEntityScanner.peekChar())) {
                        fStringBuffer.append((char)fEntityScanner.scanChar());
                    }
                    String target = fSymbolTable.addSymbol(fStringBuffer.ch, fStringBuffer.offset, fStringBuffer.length);
                    scanPIData(target, fString);
                }

                // standard XML declaration
                else {
                    scanXMLDeclOrTextDecl(false);
                }
                return complete;
            }

            // if no XMLDecl, then scan piece of prolog
            return true;

        } // dispatch(boolean):boolean

    } // class XMLDeclDispatcher

    /**
     * Dispatcher to handle prolog scanning.
     *
     * @author Andy Clark, IBM
     */
    protected final class PrologDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            boolean again;
            do {
                again = false;
                switch (fScannerState) {
                    case SCANNER_STATE_PROLOG: {
                        fEntityScanner.skipSpaces();
                        if (fEntityScanner.skipChar('<')) {
                            setScannerState(SCANNER_STATE_START_OF_MARKUP);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('&')) {
                            setScannerState(SCANNER_STATE_REFERENCE);
                            again = true;
                        }
                        else {
                            setScannerState(SCANNER_STATE_CONTENT);
                            again = true;
                        }
                        break;
                    }
                    case SCANNER_STATE_START_OF_MARKUP: {
                        if (fEntityScanner.skipChar('?')) {
                            setScannerState(SCANNER_STATE_PI);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('!')) {
                            if (fEntityScanner.skipChar('-')) {
                                if (!fEntityScanner.skipChar('-')) {
                                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                               "InvalidCommentStart",
                                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                }
                                setScannerState(SCANNER_STATE_COMMENT);
                                again = true;
                            }
                            else if (fEntityScanner.skipString("DOCTYPE")) {
                                setScannerState(SCANNER_STATE_DOCTYPE);
                                again = true;
                            }
                            else {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                           "MarkupNotRecognizedInProlog",
                                                           null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            }
                        }
                        else if (XMLChar.isNameStart(fEntityScanner.peekChar())) {
                            setScannerState(SCANNER_STATE_ROOT_ELEMENT);
                            setDispatcher(fContentDispatcher);
                            return true;
                        }
                        else {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "MarkupNotRecognizedInProlog",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                        break;
                    }
                    case SCANNER_STATE_COMMENT: {
                        scanComment();
                        setScannerState(SCANNER_STATE_PROLOG);
                        break;  
                    }
                    case SCANNER_STATE_PI: {
                        scanPI();
                        setScannerState(SCANNER_STATE_PROLOG);
                        break;  
                    }
                    case SCANNER_STATE_DOCTYPE: {
                        if (fSeenDoctypeDecl) {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "AlreadySeenDoctype",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                        fSeenDoctypeDecl = true;
                        scanDoctypeDecl();
                        setScannerState(SCANNER_STATE_PROLOG);
                        break;
                    }
                    case SCANNER_STATE_CONTENT: {
                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                   "ContentIllegalInProlog",
                                                   null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    }
                    case SCANNER_STATE_REFERENCE: {
                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                   "ReferenceIllegalInProlog",
                                                   null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    }
                }
            } while (complete || again);

            if (fEntityScanner.scanChar() != '<') {
                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                           "RootElementRequired",
                                           null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
           }
            setScannerState(SCANNER_STATE_ROOT_ELEMENT);
            setDispatcher(fContentDispatcher);

            return complete;

        } // dispatch(boolean):boolean

    } // class PrologDispatcher

    /**
     * Dispatcher to handle content scanning.
     *
     * @author Andy Clark, IBM
     * @author Eric Ye, IBM
     */
    protected final class ContentDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            boolean again;
            do {
                again = false;
                switch (fScannerState) {
                    case SCANNER_STATE_ROOT_ELEMENT: {
                        if (scanStartElement()) {
                            setScannerState(SCANNER_STATE_TRAILING_MISC);
                            setDispatcher(fTrailingMiscDispatcher);
                            return complete;
                        }
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;
                    }
                    case SCANNER_STATE_COMMENT: {
                        scanComment();
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;  
                    }
                    case SCANNER_STATE_PI: {
                        scanPI();
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;  
                    }
                    // REVISIT: Handle CDATA so that we can split up
                    //          the processing over multiple callbacks.
                    case SCANNER_STATE_CDATA: {
                        if (scanCDATASection(complete)) {
                            setScannerState(SCANNER_STATE_CONTENT);
                        }
                        break;
                    }
                    case SCANNER_STATE_REFERENCE: {
                        if (fEntityScanner.skipChar('#')) {
                            scanCharReference();
                        }
                        else {
                            scanEntityReference();
                        }
                        setScannerState(SCANNER_STATE_CONTENT);
                        break;
                    }
                    case SCANNER_STATE_CONTENT: {
                        if (fEntityScanner.skipChar('<')) {
                            setScannerState(SCANNER_STATE_START_OF_MARKUP);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('&')) {
                            setScannerState(SCANNER_STATE_REFERENCE);
                            again = true;
                        }
                        else {
                            while (complete) {
                                int c = scanContent();
                                if (c == '<') {
                                    fEntityScanner.scanChar();
                                    setScannerState(SCANNER_STATE_START_OF_MARKUP);
                                    break;
                                }
                                else if (c == '&') {
                                    fEntityScanner.scanChar();
                                    setScannerState(SCANNER_STATE_REFERENCE);
                                    break;
                                }
                                else if (c == -1) {
                                    /***
                                    
                                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, "ETagRequired",
                                                               new Object[] {fCurrentElement.rawname},
                                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);

                                    setScannerState(SCANNER_STATE_TERMINATED);
                                    return false;
                                    /***/
                                }
                                else if (XMLChar.isInvalid(c)) {
                                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInContent",
                                                               new Object[] {Integer.toString(c, 16)},
                                                               XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                }
                            }
                        }
                        break;
                    }
                    case SCANNER_STATE_START_OF_MARKUP: {
                        if (fEntityScanner.skipChar('?')) {
                            setScannerState(SCANNER_STATE_PI);
                            again = true;
                        }
                        else if (fEntityScanner.skipChar('!')) {
                            if (fEntityScanner.skipChar('-')) {
                                if (!fEntityScanner.skipChar('-')) {
                                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                               "InvalidCommentStart",
                                                               null, XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                }
                                setScannerState(SCANNER_STATE_COMMENT);
                                again = true;
                            }
                            else if (fEntityScanner.skipString("[CDATA[")) {
                                setScannerState(SCANNER_STATE_CDATA);
                                again = true;
                            }
                            else if (fEntityScanner.skipString("DOCTYPE")) {
                                setScannerState(SCANNER_STATE_DOCTYPE);
                            }
                            else {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                           "MarkupNotRecognizedInContent",
                                                           null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                            }
                        }
                        else if (fEntityScanner.skipChar('/')) {
                            if (scanEndElement() == 0) {
                                setScannerState(SCANNER_STATE_TRAILING_MISC);
                                setDispatcher(fTrailingMiscDispatcher);
                                return complete;
                            }
                            setScannerState(SCANNER_STATE_CONTENT);
                        }
                        else if (XMLChar.isNameStart(fEntityScanner.peekChar())) {
                            scanStartElement();
                            setScannerState(SCANNER_STATE_CONTENT);
                        }
                        else {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "MarkupNotRecognizedInContent",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                        break;
                    }
                    case SCANNER_STATE_DOCTYPE: {
                        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                   "DoctypeIllegalInContent",
                                                   null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                    }
                }
            } while (complete || again);

            return complete;

        } // dispatch(boolean):boolean

    } // class ContentDispatcher

    /**
     * Dispatcher to handle trailing miscellaneous section scanning.
     *
     * @author Andy Clark, IBM
     * @author Eric Ye, IBM
     */
    protected final class TrailingMiscDispatcher
        implements Dispatcher {

        //
        // Dispatcher methods
        //

        /** 
         * Dispatch an XML "event".
         *
         * @param complete True if this dispatcher is intended to scan
         *                 and dispatch as much as possible.                 
         *
         * @returns True if there is more to dispatch either from this 
         *          or a another dispatcher.
         *
         * @throws IOException  Thrown on i/o error.
         * @throws SAXException Thrown on parse error.
         */
        public boolean dispatch(boolean complete) 
            throws IOException, SAXException {

            try {
                do {
    
                    if (fEntityScanner.skipChar('<')) {
                        setScannerState(SCANNER_STATE_START_OF_MARKUP);
                        if (fEntityScanner.skipChar('?')) {
                            scanPI();
                        }
                        else if ( fEntityScanner.skipChar('!')) {
                            scanComment();
                        }
                        setScannerState(SCANNER_STATE_TRAILING_MISC);
                    }
                    else if ( fEntityScanner.skipSpaces() ) {
                        // do nothing
                    }
                    else {
                        int ch = fEntityScanner.peekChar();
    
                        if (XMLChar.isInvalid(ch)) {
                            if (ch == -1 ) {
                                setScannerState(SCANNER_STATE_TERMINATED);
                                return false;
                            }
                            else {
                                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN, "InvalidCharInMisc",
                                                           new Object[] {Integer.toString(ch, 16)},
                                                           XMLErrorReporter.SEVERITY_FATAL_ERROR);
                                setScannerState(SCANNER_STATE_TERMINATED);
                                return false;
                            }
                        }
                        else {
                            fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,
                                                       "MarkupNotRecognizedInMisc",
                                                       null,XMLErrorReporter.SEVERITY_FATAL_ERROR);
                        }
                    }
    
                } while ( complete );
            }
            catch (EOFException e) {
                // NOTE: This is the only place we're allowed to reach
                //       the real end of the document stream. So ignore
                //       the exception and move to end of input. -Ac
            }

            setScannerState(SCANNER_STATE_TERMINATED);
            return false;

        } // dispatch(boolean):boolean

    } // class TrailingMiscDispatcher

} // class XMLDocumentScanner
