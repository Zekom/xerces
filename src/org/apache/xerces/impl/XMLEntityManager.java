/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FilterReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.PushbackInputStream;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.StringReader;
import java.net.URL;
import java.util.Hashtable;
import java.util.Stack;

import org.apache.xerces.util.EncodingMap;
import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.URI;
import org.apache.xerces.util.XMLChar;

import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLString;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

/**
 * The entity manager handles the registration of general and parameter
 * entities; resolves entities; and starts entities. The entity manager
 * is a central component in a standard parser configuration and this
 * class works directly with the entity scanner to manage the underlying
 * xni.
 * <p>
 * This component requires the following features and properties from the
 * component manager that uses it:
 * <ul>
 *  <li>http://apache.org/xml/properties/internal/entity-resolver</li>
 *  <li>http://apache.org/xml/properties/internal/symbol-table</li>
 * </ul>
 *
 *
 * @author Stubs generated by DesignDoc on Mon Sep 18 18:23:16 PDT 2000
 * @author Andy Clark, IBM
 *
 * @version $Id$
 */
public class XMLEntityManager
    implements XMLComponent {

    //
    // Constants
    //

    /** Default buffer size (2048). */
    public static final int DEFAULT_BUFFER_SIZE = 2048;

    // debugging

    /** 
     * Debug printing of buffer. This debugging flag works best when you
     * resize the DEFAULT_BUFFER_SIZE down to something reasonable like
     * 64 characters.
     */
    private static final boolean DEBUG_PRINT = false;

    /** Debugging. */
    private static final boolean DEBUG = false;

    /** Debug some basic entities. */
    private static final boolean DEBUG_ENTITIES = false;

    //
    // Data
    //

    // features

    /** 
     * Buffer size. This feature does not have a feature identifier, yet. 
     * Should it?
     */
    protected int fBufferSize = DEFAULT_BUFFER_SIZE;

    // properties

    /** 
     * Entity resolver. This property identifier is:
     * http://apache.org/xml/properties/internal/entity-resolver
     */
    protected EntityResolver fEntityResolver;

    /** 
     * Symbol table. This property identifier is:
     * http://apache.org/xml/properties/internal/symbol-table
     */
    protected SymbolTable fSymbolTable;

    // handlers

    /** Entity handler. */
    protected XMLEntityHandler fEntityHandler;

    // scanner

    /** Entity scanner. */
    protected XMLEntityScanner fEntityScanner;

    // entities

    /** Entities. */
    protected Hashtable fEntities = new Hashtable();

    /** Entity stack. */
    protected Stack fEntityStack = new Stack();

    /** Current entity. */
    protected ScannedEntity fCurrentEntity;

    //
    // Constructors
    //

    /** Default constructor. */
    public XMLEntityManager() {
        fEntityScanner = new EntityScanner();
    } // <init>()

    //
    // Public methods
    //

    /**
     * setEntityHandler
     *
     * @param entityHandler The new entity handler.
     */
    public void setEntityHandler(XMLEntityHandler entityHandler) {
        fEntityHandler = entityHandler;
    } // setEntityHandler(XMLEntityHandler)

    /**
     * addInternalEntity
     * 
     * @param name 
     * @param text 
     */
    public void addInternalEntity(String name, String text) {
        Entity entity = new InternalEntity(name, text);
        fEntities.put(name, entity);
    } // addInternalEntity(String,String)

    /**
     * addExternalEntity
     * 
     * @param name 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     * @param notation
     */
    public void addExternalEntity(String name, 
                                  String publicId, String systemId, 
                                  String baseSystemId) {
        Entity entity = new ExternalEntity(name, publicId, systemId, baseSystemId, null);
        fEntities.put(name, entity);
    } // addExternalEntity(String,String,String,String)

    /**
     * addUnparsedEntity
     * 
     * @param name 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     * @param notation
     */
    public void addUnparsedEntity(String name, 
                                  String publicId, String systemId,
                                  String notation) {
        Entity entity = new ExternalEntity(name, publicId, systemId, null, notation);
        fEntities.put(name, entity);
    } // addUnparsedEntity(String,String,String,String)

    /** Returns the values for an external entity. */
    public boolean getExternalEntity(String name, ExternalEntity externalEntity) {
        Entity entity = (Entity)fEntities.get(name);
        if (entity != null && entity.isExternal()) {
            externalEntity.setValues((ExternalEntity)entity);
            return true;
        }
        return false;
    } // getExternalEntity(String,ExternalEntity):boolean

    /** Returns the values for an internal entity. */
    public boolean getInternalEntity(String name, InternalEntity internalEntity) {
        Entity entity = (Entity)fEntities.get(name);
        if (entity != null && !entity.isExternal()) {
            internalEntity.setValues((InternalEntity)entity);
            return true;
        }
        return false;
    } // getInternalEntity(String,InternalEntity):boolean

    /** Returns true if the specified entity is declared. */
    public boolean isEntityDeclared(String name) {
        return fEntities.get(name) != null;
    } // isEntityDeclared(String):boolean

    /** Returns true if the specified entity is internal. */
    public boolean isEntityExternal(String name) {
        return ((Entity)fEntities.get(name)).isExternal();
    } // isEntityExternal(String):boolean

    /**
     * resolveEntity
     * 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     * 
     * @return 
     */
    public XMLInputSource resolveEntity(String publicId, String systemId, 
                                        String baseSystemId)
        throws IOException, SAXException {

        // give the entity resolver a chance
        XMLInputSource xmlInputSource = null;
        if (fEntityResolver != null) {
            InputSource inputSource = fEntityResolver.resolveEntity(publicId, systemId);
            if (inputSource != null) {
                xmlInputSource = new XMLInputSource(inputSource);
                xmlInputSource.setBaseSystemId(baseSystemId);
                String expandedSystemId = expandSystemId(systemId, baseSystemId);
                xmlInputSource.setExpandedSystemId(expandedSystemId);
            }
        }

        // do default resolution
        if (xmlInputSource == null) {
            // if no base systemId given, assume that it's relative
            // to the systemId of the current scanned entity
            if (baseSystemId == null) {
                baseSystemId = fCurrentEntity.systemId;
            }

            // create the input source
            xmlInputSource = new XMLInputSource(systemId);
            xmlInputSource.setPublicId(publicId);
            xmlInputSource.setBaseSystemId(baseSystemId);
            String expandedSystemId = expandSystemId(systemId, baseSystemId);
            xmlInputSource.setExpandedSystemId(expandedSystemId);
        }

        return xmlInputSource;

    } // resolveEntity(String,String,String):XMLInputSource

    /**
     * startEntity
     * 
     * @param entityName 
     * @param parameter 
     */
    public void startEntity(String entityName) 
        throws IOException, SAXException {

        // resolve external entity
        Entity entity = (Entity)fEntities.get(entityName);
        XMLInputSource xmlInputSource = null;
        if (entity.isExternal()) {
            ExternalEntity externalEntity = (ExternalEntity)entity;
            String publicId = externalEntity.publicId;
            String systemId = externalEntity.systemId;
            String baseSystemId = externalEntity.baseSystemId;
            xmlInputSource = resolveEntity(publicId, systemId, baseSystemId);
        }

        // wrap internal entity
        else {
            InternalEntity internalEntity = (InternalEntity)entity;
            Reader reader = new StringReader(internalEntity.text);
            xmlInputSource = new XMLInputSource(reader);
        }

        // start the entity
        startEntity(entityName, xmlInputSource);

    } // startEntity(String)

    /**
     * startDocumentEntity
     * 
     * @param inputSource 
     */
    public void startDocumentEntity(XMLInputSource xmlInputSource) 
        throws IOException, SAXException {
        startEntity("[xml]", xmlInputSource);
    } // startDocumentEntity(XMLInputSource)

    /**
     * startDTDEntity
     *
     * @param inputSource
     */
    public void startDTDEntity(XMLInputSource xmlInputSource)
        throws IOException, SAXException {
        startEntity("[dtd]", xmlInputSource);
    } // startDTDEntity(XMLInputSource)

    /**
     * getEntityScanner
     * 
     * @return 
     */
    public XMLEntityScanner getEntityScanner() {
        return fEntityScanner;
    } // getEntityScanner():XMLEntityScanner

    //
    // XMLComponent methods
    //

    /**
     * reset
     * 
     * @param configurationManager 
     */
    public void reset(XMLComponentManager componentManager)
        throws SAXException {

        // Xerces properties
        final String ENTITY_RESOLVER = Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
        fEntityResolver = (EntityResolver)componentManager.getProperty(ENTITY_RESOLVER);
        final String SYMBOL_TABLE = Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
        fSymbolTable = (SymbolTable)componentManager.getProperty(SYMBOL_TABLE);

        // initialize state
        fEntities.clear();
        fEntityStack.removeAllElements();

        // DEBUG
        if (DEBUG_ENTITIES) {
            addInternalEntity("text", "Hello, World.");
            addInternalEntity("empty-element", "<foo/>");
            addInternalEntity("balanced-element", "<foo></foo>");
            addInternalEntity("balanced-element-with-text", "<foo>Hello, World</foo>");
            addInternalEntity("balanced-element-with-entity", "<foo>&text;</foo>");
            addInternalEntity("unbalanced-entity", "<foo>");
            addInternalEntity("recursive-entity", "<foo>&recursive-entity2;</foo>");
            addInternalEntity("recursive-entity2", "<bar>&recursive-entity3;</bar>");
            addInternalEntity("recursive-entity3", "<baz>&recursive-entity;</baz>");

            addExternalEntity("external-text", null, "external-text.ent", "test/external-text.xml");
            addExternalEntity("external-balanced-element", null, "external-balanced-element.ent", "test/external-balanced-element.xml");
            addExternalEntity("one", null, "ent/one.ent", "test/external-entity.xml");
            addExternalEntity("two", null, "ent/two.ent", "test/ent/one.xml");
        }

    } // reset(XMLComponentManager)

    /**
     * setFeature
     * 
     * @param featureId 
     * @param state 
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setFeature(String,boolean)

    /**
     * setProperty
     * 
     * @param propertyId 
     * @param value 
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        // Xerces properties
        if (propertyId.startsWith(Constants.XERCES_PROPERTY_PREFIX)) {
            String property = propertyId.substring(Constants.XERCES_PROPERTY_PREFIX.length());
            if (property.equals(Constants.ENTITY_RESOLVER_PROPERTY)) {
                fEntityResolver = (EntityResolver)value;
                return;
            }
            if (property.equals(Constants.SYMBOL_TABLE_PROPERTY)) {
                fSymbolTable = (SymbolTable)value;
                return;
            }
        }

    } // setProperty(String,Object)

    //
    // Protected methods
    //

    /**
     * Starts an entity. 
     */
    protected void startEntity(String name, XMLInputSource xmlInputSource)
        throws IOException, SAXException {

        // get information
        final String publicId = xmlInputSource.getPublicId();
        final String systemId = xmlInputSource.getSystemId();
        String encoding = xmlInputSource.getEncoding();

        // create reader
        InputStream stream = null;
        Reader reader = xmlInputSource.getCharacterStream();
        if (reader == null) {
            stream = xmlInputSource.getByteStream();
            if (stream == null) {
                String expandedSystemId = xmlInputSource.getExpandedSystemId();
                if (expandedSystemId == null) {
                    final String baseSystemId = xmlInputSource.getBaseSystemId();
                    expandedSystemId = expandSystemId(systemId, baseSystemId);
                    xmlInputSource.setExpandedSystemId(expandedSystemId);
                }
                stream = new URL(expandedSystemId).openStream();
            }
                
            // perform auto-detect of encoding
            if (encoding == null) {
                // read first four bytes and determine encoding
                final byte[] b4 = new byte[4];
                int count = stream.read(b4, 0, 4);
                encoding = getJavaEncodingName(b4, count);

                // push back the characters we read
                PushbackInputStream pbstream = new PushbackInputStream(stream, 4);
                pbstream.unread(b4, 0, count);
                stream = pbstream;

                // REVISIT: Should save the original input stream instead of
                //          the pushback input stream so that when we swap out
                //          the OneCharReader, we don't still have a method
                //          indirection to get at the underlying bytes. -Ac
            }

            // create reader from input stream
            // REVISIT: We can use customized readers here. -Ac
            reader = new InputStreamReader(stream, encoding);

            // REVISIT: Activate this reader once I've updated the
            //          entity scanner. -Ac
            //reader = new OneCharReader(reader);
        }

        // push entity on stack
        if (fCurrentEntity != null) {
            fEntityStack.push(fCurrentEntity);
        }
        fCurrentEntity = new ScannedEntity(name, publicId, systemId, 
                                           stream, reader, encoding);

        // call handler
        if (fEntityHandler != null) {
            String ianaEncoding = encoding != null
                                ? EncodingMap.getJava2IANAMapping(encoding)
                                : null;
            fEntityHandler.startEntity(name, publicId, systemId, ianaEncoding);
        }

    } // startEntity(String,XMLInputSource)

    /**
     * Ends an entity.
     */
    protected void endEntity() throws SAXException {

        // call handler
        if (DEBUG_PRINT) {
            System.out.println("(endEntity: ");
            print();
            System.out.println();
        }
        if (fEntityHandler != null) {
            fEntityHandler.endEntity(fCurrentEntity.name);
        }

        // pop stack
        fCurrentEntity = fEntityStack.size() > 0
                       ? (ScannedEntity)fEntityStack.pop() : null;
        if (DEBUG_PRINT) {
            System.out.println(")endEntity: ");
            print();
            System.out.println();
        }

    } // endEntity()

    /**
     * Expands a system id and returns the system id as a URI, if
     * it can be expanded. A return value of null means that the
     * identifier is already expanded. An exception thrown
     * indicates a failure to expand the id.
     *
     * @param systemId The systemId to be expanded.
     *
     * @return Returns the URI string representing the expanded system
     *         identifier. A null value indicates that the given
     *         system identifier is already expanded.
     *
     */
    public static String expandSystemId(String systemId) {
        return expandSystemId(systemId, null);
    } // expandSystemId(String):String

    /**
     * Expands a system id and returns the system id as a URI, if
     * it can be expanded. A return value of null means that the
     * identifier is already expanded. An exception thrown
     * indicates a failure to expand the id.
     *
     * @param systemId The systemId to be expanded.
     *
     * @return Returns the URI string representing the expanded system
     *         identifier. A null value indicates that the given
     *         system identifier is already expanded.
     *
     */
    public static String expandSystemId(String systemId, String baseSystemId) {

        // check for bad parameters id
        if (systemId == null || systemId.length() == 0) {
            return systemId;
        }

        // if id already expanded, return
        try {
            URI uri = new URI(systemId);
            if (uri != null) {
                return systemId;
            }
        }
        catch (URI.MalformedURIException e) {
            // continue on...
        }

        // normalize id
        String id = fixURI(systemId);

        // normalize base
        URI base = null;
        URI uri = null;
        try {
            if (baseSystemId == null) {
                String dir;
                try {
                    dir = fixURI(System.getProperty("user.dir"));
                }
                catch (SecurityException se) {
                    dir = "";
                }
                if (!dir.endsWith("/")) {
                    dir = dir + "/";
                }
                base = new URI("file", "", dir, null, null);
            }
            else {
                try {
                    base = new URI(baseSystemId);
                }
                catch (URI.MalformedURIException e) {
                    String dir;
                    try {
                        dir = fixURI(System.getProperty("user.dir"));
                    }
                    catch (SecurityException se) {
                        dir = "";
                    }
                    if (!dir.endsWith("/")) {
                        dir = dir + "/";
                    }
                    dir = dir + baseSystemId;
                    base = new URI("file", "", dir, null, null);
                }
            }

            // expand id
            uri = new URI(base, id);
        }
        catch (Exception e) {
            // let it go through
        }
        if (uri == null) {
            return systemId;
        }
        return uri.toString();

    } // expandSystemId(String,String):String

    //
    // Private methods
    //

    /**
     * Returns the Java encoding name that is auto-detected from
     * the bytes specified.
     *
     * @param b4    The first four bytes of the input.
     * @param count The number of bytes actually read.
     *
     * @returns The Java encoding name.
     */
    private static String getJavaEncodingName(byte[] b4, int count) {

        if (count < 2) {
            return "UTF8";
        }

        // UTF-16, with BOM
        byte b0 = b4[0];
        byte b1 = b4[1];
        if (b0 == 0xFE && b1 == 0xFF) {
            // UTF-16, big-endian
            return "UnicodeBig";
        }
        if (b0 == 0xFF && b1 == 0xFE) {
            // UTF-16, little-endian
            return "UnicodeLittle";
        }

        if (count < 4) {
            return "UTF8";
        }

        // other encodings
        byte b2 = b4[2];
        byte b3 = b4[3];
        if (b0 == 0x00 && b1 == 0x00 && b2 == 0x00 && b3 == 0x3C) {
            // UCS-4, big endian (1234)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b0 == 0x3C && b1 == 0x00 && b2 == 0x00 && b3 == 0x00) {
            // UCS-4, little endian (4321)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b0 == 0x00 && b1 == 0x00 && b2 == 0x3C && b3 == 0x00) {
            // UCS-4, unusual octet order (2143)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x00) {
            // UCS-4, unusual octect order (3412)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b1 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x3F) {
            // UTF-16, big-endian, no BOM
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b1 == 0x3C && b1 == 0x00 && b2 == 0x3F && b3 == 0x00) {
            // UTF-16, little-endian, no BOM
            return "UnicodeLittle";
        }
        if (b1 == 0x4C && b1 == 0x6F && b2 == 0xA7 && b3 == 0x94) {
            // EBCDIC
            return "DBCS_EBCDIC";
        }

        // default encoding
        return "UTF8";

    } // getJavaEncodingName(byte[],int):String

    /**
     * Fixes a platform dependent filename to standard URI form.
     *
     * @param str The string to fix.
     *
     * @return Returns the fixed URI string.
     */
    private static String fixURI(String str) {

        // handle platform dependent strings
        str = str.replace(java.io.File.separatorChar, '/');

        // Windows fix
        if (str.length() >= 2) {
            char ch1 = str.charAt(1);
            if (ch1 == ':') {
                char ch0 = Character.toUpperCase(str.charAt(0));
                if (ch0 >= 'A' && ch0 <= 'Z') {
                    str = "/" + str;
                }
            }
        }

        // done
        return str;

    } // fixURI(String):String

    /** Prints the contents of the buffer. */
    final void print() {
        if (DEBUG_PRINT) {
            System.out.print('[');
            System.out.print(fCurrentEntity.count);
            if (fCurrentEntity.count > 0) {
                System.out.print(" \"");
                for (int i = 0; i < fCurrentEntity.count; i++) {
                    if (i == fCurrentEntity.position) {
                        System.out.print('^');
                    }
                    char c = fCurrentEntity.ch[i];
                    switch (c) {
                        case '\n': {
                            System.out.print("\\n");
                            break;
                        }
                        case '\r': {
                            System.out.print("\\r");
                            break;
                        }
                        case '\t': {
                            System.out.print("\\t");
                            break;
                        }
                        case '\\': {
                            System.out.print("\\\\");
                            break;
                        }
                        default: {
                            System.out.print(c);
                        }
                    }
                }
                if (fCurrentEntity.position == fCurrentEntity.count) {
                    System.out.print('^');
                }
                System.out.print('"');
            }
            System.out.print(']');
        }
    } // print()

    //
    // Classes
    //

    /**
     * Entity information.
     *
     * @author Andy Clark, IBM
     */
    public static abstract class Entity {

        //
        // Data
        //

        /** Entity name. */
        public String name;

        //
        // Constructors
        //

        /** Default constructor. */
        public Entity() {
            clear();
        } // <init>()

        /** Constructs an entity. */
        public Entity(String name) {
            this.name = name;
        } // <init>(String)

        //
        // Public methods
        //

        /** Returns true if this is an external entity. */
        public abstract boolean isExternal();

        /** Clears the entity. */
        public void clear() {
            name = null;
        } // clear()

        /** Sets the values of the entity. */
        public void setValues(Entity entity) {
            name = entity.name;
        } // setValues(Entity)

    } // class Entity

    /**
     * Internal entity.
     *
     * @author Andy Clark, IBM
     */
    public static class InternalEntity
        extends Entity {

        //
        // Data
        //

        /** Text value of entity. */
        public String text;

        //
        // Constructors
        //

        /** Default constructor. */
        public InternalEntity() {
            clear();
        } // <init>()

        /** Constructs an internal entity. */
        public InternalEntity(String name, String text) {
            super(name);
            this.text = text;
        } // <init>(String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return false;
        } // isExternal():boolean

        /** Clears the entity. */
        public void clear() {
            super.clear();
            text = null;
        } // clear()

        /** Sets the values of the entity. */
        public void setValues(Entity entity) {
            super.setValues(entity);
            text = null;
        } // setValues(Entity)

        /** Sets the values of the entity. */
        public void setValues(InternalEntity entity) {
            super.setValues(entity);
            text = entity.text;
        } // setValues(InternalEntity)

    } // class InternalEntity

    /**
     * External entity.
     *
     * @author Andy Clark, IBM
     */
    public static class ExternalEntity 
        extends Entity {
        
        //
        // Data
        //
    
        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Base system identifier. */
        public String baseSystemId;

        /** Notation name for unparsed entity. */
        public String notation;

        //
        // Constructors
        //

        /** Default constructor. */
        public ExternalEntity() {
            clear();
        } // <init>()

        /** Constructs an internal entity. */
        public ExternalEntity(String name, String publicId, String systemId,
                              String baseSystemId, String notation) {
            super(name);
            this.publicId = publicId;
            this.systemId = systemId;
            this.baseSystemId = baseSystemId;
            this.notation = notation;
        } // <init>(String,String,String,String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return true;
        } // isExternal():boolean

        /** Clears the entity. */
        public void clear() {
            super.clear();
            publicId = null;
            systemId = null;
            baseSystemId = null;
            notation = null;
        } // clear()

        /** Sets the values of the entity. */
        public void setValues(Entity entity) {
            super.setValues(entity);
            publicId = null;
            systemId = null;
            baseSystemId = null;
            notation = null;
        } // setValues(Entity)

        /** Sets the values of the entity. */
        public void setValues(ExternalEntity entity) {
            super.setValues(entity);
            publicId = entity.publicId;;
            systemId = entity.systemId;
            baseSystemId = entity.baseSystemId;
            notation = entity.notation;
        } // setValues(ExternalEntity)

    } // class ExternalEntity

    /**
     * Entity state.
     *
     * @author Andy Clark, IBM
     */
    protected class ScannedEntity 
        extends Entity {

        //
        // Data
        //

        // i/o

        /** Input stream. */
        public InputStream stream;

        /** Reader. */
        public Reader reader;

        // locator information

        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Line number. */
        public int lineNumber;

        /** Column number. */
        public int columnNumber;

        // encoding

        /** Auto-detected encoding. */
        public String encoding;

        // buffer

        /** Character buffer. */
        public char[] ch = new char[fBufferSize];

        /** Position in character buffer. */
        public int position;

        /** Count of characters in buffer. */
        public int count;

        //
        // Constructors
        //

        /** Constructs a scanned entity. */
        public ScannedEntity(String name, String publicId, String systemId,
                             InputStream stream, Reader reader, 
                             String encoding) {
            super(name);
            this.publicId = publicId;
            this.systemId = systemId;
            this.stream = stream;
            this.reader = reader;
            this.encoding = encoding;
        } // <init>(Reader,String,String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return systemId != null;
        } // isExternal():boolean

        //
        // Object methods
        //

        /** Returns a string representation of this object. */
        public String toString() {

            StringBuffer str = new StringBuffer();
            str.append("name=\""+name+'"');
            str.append(",ch="+ch);
            str.append(",position="+position);
            str.append(",count="+count);
            return str.toString();

        } // toString():String

    } // class ScannedEntity

    /**
     * Implements the entity scanner methods.
     *
     * @author Andy Clark, IBM
     */
    private class EntityScanner
        extends XMLEntityScanner {
    
        //
        // Constructors
        //
    
        /** Default constructor. */
        public EntityScanner() {
        } // <init>()
    
        //
        // XMLEntityScanner methods
        //
    
        public void setEncoding(String encoding) throws IOException {
            if (fCurrentEntity.stream != null) {
                OneCharReader ocreader = (OneCharReader)fCurrentEntity.reader;
                fCurrentEntity.reader = ocreader.getReader();
            }
        } // setEncoding(String)

        /**
         * peekChar
         * 
         * @return 
         */
        public int peekChar() throws IOException, SAXException {
            if (DEBUG) System.out.println("#peekChar()");

            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("peekChar: ");
                print();
                System.out.println(" -> '"+fCurrentEntity.ch[fCurrentEntity.position]+"'");
            }
            return fCurrentEntity.ch[fCurrentEntity.position];

        } // peekChar():int
    
        /**
         * scanChar
         * 
         * @return 
         */
        public int scanChar() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanChar()");

            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanChar: ");
                print();
                System.out.println();
            }
            int c = fCurrentEntity.ch[fCurrentEntity.position++];
            if (DEBUG_PRINT) {
                System.out.print(")scanChar: ");
                print();
                System.out.println(" -> '"+(char)c+"'");
            }
            return c;

        } // scanChar():int
    
        /**
         * scanNmtoken
         * 
         * @return 
         */
        public String scanNmtoken() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanNmtoken()");
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanNmtoken: ");
                print();
                System.out.println();
            }

            int offset = fCurrentEntity.position;
            while (XMLChar.isName(fCurrentEntity.ch[fCurrentEntity.position])) {
                if (++fCurrentEntity.position == fCurrentEntity.ch.length) {
                    int length = fCurrentEntity.position - offset;
                    System.arraycopy(fCurrentEntity.ch, offset, fCurrentEntity.ch, 0, length);
                    offset = 0;
                    if (load(length, false)) {
                        break;
                    }
                }
            }
            int length = fCurrentEntity.position - offset;

            String symbol = null;
            if (length > 0) {
                symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, offset, length);
            }
            if (DEBUG_PRINT) {
                System.out.print(")scanNmtoken: ");
                print();
                System.out.println(" -> "+String.valueOf(symbol));
            }
            return symbol;
    
        } // scanNmtoken():String
    
        /**
         * scanName
         * 
         * @return 
         */
        public String scanName() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanName()");
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanName: ");
                print();
                System.out.println();
            }

            int offset = fCurrentEntity.position;
            if (XMLChar.isNameStart(fCurrentEntity.ch[offset])) {
                if (++fCurrentEntity.position == fCurrentEntity.count) {
                    fCurrentEntity.ch[0] = fCurrentEntity.ch[offset];
                    offset = 0;
                    if (load(1, false)) {
                        String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 1);
                        if (DEBUG_PRINT) {
                            System.out.print(")scanName: ");
                            print();
                            System.out.println(" -> "+String.valueOf(symbol));
                        }
                        return symbol;
                    }
                }
                while (XMLChar.isName(fCurrentEntity.ch[fCurrentEntity.position])) {
                    if (++fCurrentEntity.position == fCurrentEntity.count) {
                        int length = fCurrentEntity.position - offset;
                        System.arraycopy(fCurrentEntity.ch, offset, fCurrentEntity.ch, 0, length);
                        offset = 0;
                        if (load(length, false)) {
                            break;
                        }
                    }
                }
            }
            int length = fCurrentEntity.position - offset;

            String symbol = null;
            if (length > 0) {
                symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, offset, length);
            }
            if (DEBUG_PRINT) {
                System.out.print(")scanName: ");
                print();
                System.out.println(" -> "+String.valueOf(symbol));
            }
            return symbol;
    
        } // scanName():String
    
        /**
         * scanQName
         * 
         * @param qname 
         */
        public boolean scanQName(QName qname) throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanQName()");
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanQName, "+qname+": ");
                print();
                System.out.println(" -> true");
            }

            int offset = fCurrentEntity.position;
            if (XMLChar.isNameStart(fCurrentEntity.ch[offset])) {
                if (++fCurrentEntity.position == fCurrentEntity.count) {
                    fCurrentEntity.ch[0] = fCurrentEntity.ch[offset];
                    offset = 0;
                    if (load(1, false)) {
                        String name = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 1);
                        qname.setValues(null, name, name, null);
                        if (DEBUG_PRINT) {
                            System.out.print(")scanQName, "+qname+": ");
                            print();
                            System.out.println(" -> true");
                        }
                        return true;
                    }
                }
                int index = -1;
                while (XMLChar.isName(fCurrentEntity.ch[fCurrentEntity.position])) {
                    char c = fCurrentEntity.ch[fCurrentEntity.position];
                    if (c == ':') {
                        if (index != -1) {
                            break;
                        }
                        index = offset;
                    }
                    if (++fCurrentEntity.position == fCurrentEntity.count) {
                        int length = fCurrentEntity.position - offset;
                        System.arraycopy(fCurrentEntity.ch, offset, fCurrentEntity.ch, 0, length);
                        offset = 0;
                        if (load(length, false)) {
                            break;
                        }
                    }
                }
                int length = fCurrentEntity.position - offset;
                if (length > 0) {
                    String prefix = null;
                    String localpart = null;
                    String rawname = null;
                    if (index != -1) {
                        prefix = fSymbolTable.addSymbol(fCurrentEntity.ch, offset, index - offset);
                        localpart = fSymbolTable.addSymbol(fCurrentEntity.ch, offset + index + 1, length - index - 1);
                    }
                    else {
                        localpart = fSymbolTable.addSymbol(fCurrentEntity.ch, offset, length);
                        rawname = localpart;
                    }
                    qname.setValues(prefix, localpart, rawname, null);
                    if (DEBUG_PRINT) {
                        System.out.print(")scanQName, "+qname+": ");
                        print();
                        System.out.println(" -> true");
                    }
                    return true;
                }
            }

            if (DEBUG_PRINT) {
                System.out.print(")scanQName, "+qname+": ");
                print();
                System.out.println(" -> false");
            }
            return false;
    
        } // scanQName(QName):boolean
    
        /**
         * scanContent
         * 
         * @param content 
         */
        public int scanContent(XMLString content) 
            throws IOException, SAXException {
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
                fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
                load(1, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanContent: ");
                print();
                System.out.println();
            }

            // REVISIT: Use AndyH trick for grabbing longest runs of
            //          content characters. -Ac
            int offset = fCurrentEntity.position;
            while (fCurrentEntity.position < fCurrentEntity.count) {
                char c = fCurrentEntity.ch[fCurrentEntity.position++];
                if (c == '<' || c == '&') {
                    fCurrentEntity.position--;
                    break;
                }
            }
            int length = fCurrentEntity.position - offset;
            content.setValues(fCurrentEntity.ch, offset, length);
    
            // return next character
            int c = -1;
            if (fCurrentEntity.position != fCurrentEntity.count) {
                c = fCurrentEntity.ch[fCurrentEntity.position];
            }
            if (DEBUG_PRINT) {
                System.out.print(")scanContent: ");
                print();
                System.out.println(" -> '"+(char)c+"'");
            }
            return c;
    
        } // scanContent(XMLString):int
    
        /**
         * scanAttContent
         * 
         * @param quote
         * @param content 
         */
        public int scanAttContent(int quote, XMLString content)
            throws IOException, SAXException {
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
                fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
                load(1, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanAttContent, '"+(char)quote+"': ");
                print();
                System.out.println();
            }

            // REVISIT: Handle entity reference in attribute value. -Ac
            int offset = fCurrentEntity.position;
            while (fCurrentEntity.position < fCurrentEntity.count) {
                char c = fCurrentEntity.ch[fCurrentEntity.position++];
                if (c == quote) {
                    fCurrentEntity.position--;
                    break;
                }
            }
            int length = fCurrentEntity.position - offset;
            content.setValues(fCurrentEntity.ch, offset, length);
    
            // return next character
            int c = -1;
            if (fCurrentEntity.position != fCurrentEntity.count) {
                c = fCurrentEntity.ch[fCurrentEntity.position];
            }
            if (DEBUG_PRINT) {
                System.out.print(")scanAttContent, '"+(char)quote+"': ");
                print();
                System.out.println(" -> '"+(char)c+"'");
            }
            return c;
    
        } // scanAttContent(int,XMLString):int
    
        /**
         * scanData scans data up to the given delimiter (which is consumed).
         * This assumes the internal buffer is at least bigger than the size
         * of the delimiter, and that the delimiter contains at least one char.
         *
         * @param delimiter The end delimiter to look for.
         * @param data The string to fill in with the scanned data.
         */
        public boolean scanData(String delimiter, XMLString data)
            throws IOException, SAXException {

            int delimLen = delimiter.length();
            char charAt0 = delimiter.charAt(0); 
            int limit = fCurrentEntity.count - delimLen + 1;

            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            else if (fCurrentEntity.position == limit) {
                System.arraycopy(fCurrentEntity.ch, fCurrentEntity.position,
                                 fCurrentEntity.ch, 0, delimLen - 1);
                load(delimLen - 1, true);
                fCurrentEntity.position = 0;
            }
            if (DEBUG_PRINT) {
                System.out.print("(scanData: ");
                print();
                System.out.println();
            }

            int offset = fCurrentEntity.position;
            boolean done = false;
            // iterate over buffer until there isn't enough chars left
            // for the delimiter to be there
            while (fCurrentEntity.position < limit) {
                char c = fCurrentEntity.ch[fCurrentEntity.position++];
                if (c == charAt0) {
                    // looks like we just hit the delimiter
                    int i;
                    for (i = 1; i < delimLen; i++) {
                        c = fCurrentEntity.ch[fCurrentEntity.position++];
                        if (c != delimiter.charAt(i)) {
                            break;
                        }
                    }
                    if (i == delimLen) {
                        // that was it, we're all set
                        done = true;
                        break;
                    }
                }
            }

            int length = fCurrentEntity.position - offset;
            if (done) {
                length -= delimLen;
            }
            data.setValues(fCurrentEntity.ch, offset, length);

            if (DEBUG_PRINT) {
                System.out.print(")scanData: ");
                print();
                System.out.println(" -> " + done);
            }
            return !done;

        } // scanData(String,XMLString)
    
        /**
         * skipChar
         *
         * @param c
         */
        public boolean skipChar(int c) throws IOException, SAXException {

            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(skipChar, '"+(char)c+"': ");
                print();
                System.out.println();
            }

            if (fCurrentEntity.ch[fCurrentEntity.position] == c) {
                fCurrentEntity.position++;
                if (DEBUG_PRINT) {
                    System.out.print(")skipChar, '"+(char)c+"': ");
                    print();
                    System.out.println(" -> true");
                }
                return true;
            }
            if (DEBUG_PRINT) {
                System.out.print(")skipChar, '"+(char)c+"': ");
                print();
                System.out.println(" -> false");
            }
            return false;

        } // skipChar(int):boolean
    
        /**
         * skipSpaces
         */
        public boolean skipSpaces() throws IOException, SAXException {
            if (DEBUG) System.out.println("#skipSpaces()");
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(skipSpaces: ");
                print();
                System.out.println();
            }

            if (XMLChar.isSpace(fCurrentEntity.ch[fCurrentEntity.position])) {
                fCurrentEntity.position++;
                LOOP: while (true) {
                    while (fCurrentEntity.position < fCurrentEntity.count) {
                        if (!XMLChar.isSpace(fCurrentEntity.ch[fCurrentEntity.position])) {
                            break LOOP;
                        }
                        fCurrentEntity.position++;
                    }
                    load(0, true);
                }
                if (DEBUG_PRINT) {
                    System.out.print(")skipSpaces: ");
                    print();
                    System.out.println(" -> true");
                }
                return true;
            }
            if (DEBUG_PRINT) {
                System.out.print(")skipSpaces: ");
                print();
                System.out.println(" -> false");
            }
            return false;
    
        } // skipSpaces():boolean
    
        /**
         * skipString
         *
         * @param s
         */
        public boolean skipString(String s) throws IOException, SAXException {
            if (DEBUG) System.out.println("#skipString(\""+s+"\")");
    
            if (fCurrentEntity.position == fCurrentEntity.count) {
                load(0, true);
            }
            if (DEBUG_PRINT) {
                System.out.print("(skipString, \""+s+"\": ");
                print();
                System.out.println();
            }

            int length = s.length();
            for (int i = 0; i < length; i++) {
                char c = fCurrentEntity.ch[fCurrentEntity.position++];
                if (c != s.charAt(i)) {
                    fCurrentEntity.position -= i + 1;
                    if (DEBUG_PRINT) {
                        System.out.print(")skipString, \""+s+"\": ");
                        print();
                        System.out.println(" -> false");
                    }
                    return false;
                }
                if (fCurrentEntity.position == fCurrentEntity.count) {
                    System.arraycopy(fCurrentEntity.ch, fCurrentEntity.count - i - 1, fCurrentEntity.ch, 0, i + 1);
                    // REVISIT: Can a string to be skipped cross an
                    //          entity boundary? -Ac
                    if (load(i + 1, false)) {
                        fCurrentEntity.position -= i + 1;
                        if (DEBUG_PRINT) {
                            System.out.print(")skipString, \""+s+"\": ");
                            print();
                            System.out.println(" -> false");
                        }
                        return false;
                    }
                }
            }
            if (DEBUG_PRINT) {
                System.out.print(")skipString, \""+s+"\": ");
                print();
                System.out.println(" -> true");
            }
            return true;
    
        } // skipString(String):boolean
    
        //
        // Locator methods
        //
    
        /**
         * getPublicId
         * 
         * @return 
         */
        public String getPublicId() {
            return fCurrentEntity != null ? fCurrentEntity.publicId : null;
        } // getPublicId():String
    
        /**
         * getSystemId
         * 
         * @return 
         */
        public String getSystemId() {
            return fCurrentEntity != null ? fCurrentEntity.systemId : null;
        } // getSystemId():String
    
        /**
         * getLineNumber
         * 
         * @return 
         */
        public int getLineNumber() {
            return fCurrentEntity != null ? fCurrentEntity.lineNumber : -1;
        } // getLineNumber():int
    
        /**
         * getColumnNumber
         * 
         * @return 
         */
        public int getColumnNumber() {
            return fCurrentEntity != null ? fCurrentEntity.columnNumber : -1;
        } // getColumnNumber():int
    
        //
        // Private methods
        //
    
        /** 
         * Loads a chunk of text. 
         *
         * @param offset       The offset into the character buffer to 
         *                     read the next batch of characters.
         * @param changeEntity True if the load should change entities
         *                     at the end of the entity, otherwise leave
         *                     the current entity in place and the entity
         *                     boundary will be signaled by the return
         *                     value.
         *
         * @returns Returns true if the entity changed as a result of this
         *          load operation.
         */
        private final boolean load(int offset, boolean changeEntity) 
            throws IOException, SAXException {
            if (DEBUG) System.out.println("*** load() ***");
            if (DEBUG_PRINT) {
                System.out.print("(load, "+offset+": ");
                print();
                System.out.println();
            }

            // read characters
            int length = fCurrentEntity.ch.length - offset;
            if (DEBUG_PRINT) System.out.println("  length to try to read: "+length);
            int count = fCurrentEntity.reader.read(fCurrentEntity.ch, offset, length);
            if (DEBUG_PRINT) System.out.println("  length actually read:  "+count);

            // reset count and position
            boolean entityChanged = false;
            if (count != -1) {
                fCurrentEntity.count = count + offset;
                fCurrentEntity.position = fCurrentEntity.count > 0 ? offset : -1;
            }

            // end of this entity
            else {
                entityChanged = true;
                if (changeEntity) {
                    endEntity();
                    if (fCurrentEntity == null) {
                        throw new EOFException();
                    }
                    // REVISIT: Does anything else have to occur here? -Ac
                }
            }
            if (DEBUG_PRINT) {
                System.out.print(")load, "+offset+": ");
                print();
                System.out.println();
            }

            return entityChanged;

        } // load(int):boolean
    
    } // class EntityScanner

    /**
     * A reader that reads only one character at a time. This is
     * needed for those times when we've auto-detected the encoding
     * from an input stream and need to swap out the reader once
     * the xmlDecl/textDecl has been read and processed. If we
     * read too far, then we could erroneously convert bytes from
     * the input stream to the wrong character code point.
     *
     * @author Andy Clark, IBM
     */
    protected class OneCharReader
        extends FilterReader {

        //
        // Data
        //

        /** True if we've seen the end of the first markup. */
        private boolean seenEndOfMarkup;

        //
        // Constructors
        //

        /** Constructs this reader from another reader. */
        public OneCharReader(Reader reader) {
            super(reader);
        } // <init>(Reader)

        //
        // Public methods
        //

        /** Returns the reader that is being wrapped. */
        public Reader getReader() {
            return in;
        } // getReader():Reader

        //
        // Reader methods
        //

        /** Returns a single character. */
        public int read() throws IOException {

            // swap out this inefficient reader because we've
            // already passed the first piece of markup and
            // the encoding was not set
            if (seenEndOfMarkup) {
                fCurrentEntity.reader = getReader();
                return fCurrentEntity.reader.read();
            }

            // read character and look for end of markup
            int c = in.read();
            seenEndOfMarkup = c == '>';
            return c;

        } // read():int

        /** 
         * Reads as many characters as possible which, in this case,
         * is only a single character.
         */
        public int read(char[] ch, int offset, int length)
            throws IOException {

            // handle end of file
            int c = read();
            if (c == -1) {
                return 0;
            }

            // return the 1 character
            ch[offset] = (char)c;
            return 1;

        } // read(char[],int,int):int

    } // class OneCharReader

} // class XMLEntityManager
