/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.FilterReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.PushbackInputStream;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.Hashtable;
import java.util.Stack;

import org.apache.xerces.util.EncodingMap;
import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.URI;
import org.apache.xerces.util.XMLChar;

import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLEntityHandler;
import org.apache.xerces.xni.XMLString;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

/**
 * The entity manager handles the registration of general and parameter
 * entities; resolves entities; and starts entities. The entity manager
 * is a central component in a standard parser configuration and this
 * class works directly with the entity scanner to manage the underlying
 * xni.
 * <p>
 * This component requires the following features and properties from the
 * component manager that uses it:
 * <ul>
 *  <li>http://apache.org/xml/properties/internal/entity-resolver</li>
 *  <li>http://apache.org/xml/properties/internal/symbol-table</li>
 * </ul>
 *
 *
 * @author Stubs generated by DesignDoc on Mon Sep 18 18:23:16 PDT 2000
 * @author Andy Clark, IBM
 *
 * @version $Id$
 */
public class XMLEntityManager
    implements XMLComponent {

    //
    // Constants
    //

    /** Default buffer size (1024). */
    public static final int DEFAULT_BUFFER_SIZE = 1024;

    // xerces features

    /** Xerces feature prefix. */
    //protected static final String XERCES_FEATURE_PREFIX = "http://apache.org/xml/features/";

    // xerces properties

    /** Xerces property prefix. */
    protected static final String XERCES_PROPERTY_PREFIX = "http://apache.org/xml/properties/";

    /** Entity resolver property id. */
    protected static final String ENTITY_RESOLVER_PROPERTY = "internal/entity-resolver";

    /** Symbol table property id. */
    protected static final String SYMBOL_TABLE_PROPERTY = "internal/symbol-table";

    // debugging

    /** Debugging. */
    private static final boolean DEBUG = false;

    //
    // Data
    //

    // features

    /** 
     * Buffer size. This feature does not have a feature identifier, yet. 
     * Should it?
     */
    protected int fBufferSize = DEFAULT_BUFFER_SIZE;

    // properties

    /** 
     * Entity resolver. This property identifier is:
     * http://apache.org/xml/properties/internal/entity-resolver
     */
    protected EntityResolver fEntityResolver;

    /** 
     * Symbol table. This property identifier is:
     * http://apache.org/xml/properties/internal/symbol-table
     */
    protected SymbolTable fSymbolTable;

    // handlers

    /** Entity handler. */
    protected XMLEntityHandler fEntityHandler;

    // scanner

    /** Entity scanner. */
    protected XMLEntityScanner fEntityScanner;

    // entities

    /** Entities. */
    protected Hashtable fEntities = new Hashtable();

    /** Entity stack. */
    protected Stack fEntityStack = new Stack();

    /** Current entity. */
    protected ScannedEntity fCurrentEntity;

    //
    // Constructors
    //

    /** Default constructor. */
    public XMLEntityManager() {
        fEntityScanner = new EntityScanner();
    }

    //
    // Public methods
    //

    /**
     * setEntityHandler
     *
     * @param entityHandler The new entity handler.
     */
    public void setEntityHandler(XMLEntityHandler entityHandler) {
        fEntityHandler = entityHandler;
    }

    /**
     * addExternalEntity
     * 
     * @param name 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     */
    public void addExternalEntity(String name, String publicId, String systemId, String baseSystemId) {
        Entity entity = new ExternalEntity(name, publicId, systemId, baseSystemId);
        fEntities.put(name, entity);
    } // addExternalEntity(String,String,String,String)

    /**
     * addInternalEntity
     * 
     * @param name 
     * @param text 
     */
    public void addInternalEntity(String name, String text) {
        Entity entity = new InternalEntity(name, text);
        fEntities.put(name, entity);
    } // addInternalEntity(String,String)

    /**
     * resolveEntity
     * 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     * 
     * @return 
     */
    public InputSource resolveEntity(String publicId, String systemId, String baseSystemId)
        throws IOException, SAXException {

        // give the entity resolver a chance
        InputSource inputSource = null;
        if (fEntityResolver != null) {
            inputSource = fEntityResolver.resolveEntity(publicId, systemId);
        }

        // do default resolution
        if (inputSource == null) {
            // if no base systemId given, assume that it's relative
            // to the systemId of the current scanned entity
            if (baseSystemId == null) {
                baseSystemId = fCurrentEntity.systemId;
            }

            // expand the system id
            systemId = expandSystemId(systemId, baseSystemId);
            inputSource = new InputSource(systemId);
            inputSource.setPublicId(publicId);
        }

        return inputSource;

    } // resolveEntity

    /**
     * startEntity
     * 
     * @param entityName 
     * @param parameter 
     */
    public void startEntity(String entityName) 
        throws IOException, SAXException {

        // resolve external entity
        Entity entity = (Entity)fEntities.get(entityName);
        InputSource inputSource = null;
        if (entity.isExternal()) {
            ExternalEntity externalEntity = (ExternalEntity)entity;
            String publicId = externalEntity.publicId;
            String systemId = externalEntity.systemId;
            String baseSystemId = externalEntity.baseSystemId;
            inputSource = resolveEntity(publicId, systemId, baseSystemId);
        }

        // wrap internal entity
        else {
            InternalEntity internalEntity = (InternalEntity)entity;
            Reader reader = new StringReader(internalEntity.text);
            inputSource = new InputSource(reader);
        }

        // start the entity
        startEntity(entityName, inputSource);

    } // startEntity(String)

    /**
     * startDocumentEntity
     * 
     * @param inputSource 
     */
    public void startDocumentEntity(InputSource inputSource) 
        throws IOException, SAXException {
        startEntity("[xml]", inputSource);
    } // startDocumentEntity(InputSource)

    /**
     * startDTDEntity
     *
     * @param inputSource
     */
    public void startDTDEntity(InputSource inputSource)
        throws IOException, SAXException {
        startEntity("[dtd]", inputSource);
    } // startDTDEntity(InputSource)

    /**
     * getEntityScanner
     * 
     * @return 
     */
    public XMLEntityScanner getEntityScanner() {
        return fEntityScanner;
    } // getEntityScanner

    //
    // XMLComponent methods
    //

    /**
     * reset
     * 
     * @param configurationManager 
     */
    public void reset(XMLComponentManager componentManager)
        throws SAXException {

        // Xerces properties
        final String ENTITY_RESOLVER = XERCES_PROPERTY_PREFIX + ENTITY_RESOLVER_PROPERTY;
        fEntityResolver = (EntityResolver)componentManager.getProperty(ENTITY_RESOLVER);
        final String SYMBOL_TABLE = XERCES_PROPERTY_PREFIX + SYMBOL_TABLE_PROPERTY;
        fSymbolTable = (SymbolTable)componentManager.getProperty(SYMBOL_TABLE);

        // initialize state
        fEntities.clear();
        fEntityStack.removeAllElements();

        // add default entities
        addInternalEntity("lt", "<");
        addInternalEntity("gt", ">");
        addInternalEntity("amp", "&");
        addInternalEntity("apos", "'");
        addInternalEntity("quot", "\"");

    } // reset(XMLComponentManager)

    /**
     * setFeature
     * 
     * @param featureId 
     * @param state 
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setFeature(String,boolean)

    /**
     * setProperty
     * 
     * @param propertyId 
     * @param value 
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        // Xerces properties
        if (propertyId.startsWith(XERCES_PROPERTY_PREFIX)) {
            String property = propertyId.substring(XERCES_PROPERTY_PREFIX.length());
            if (property.equals(ENTITY_RESOLVER_PROPERTY)) {
                fEntityResolver = (EntityResolver)value;
                return;
            }
            if (property.equals(SYMBOL_TABLE_PROPERTY)) {
                fSymbolTable = (SymbolTable)value;
                return;
            }
        }

    } // setProperty(String,Object)

    //
    // Protected methods
    //

    /**
     * Starts an entity. 
     */
    protected void startEntity(String name, InputSource inputSource)
        throws IOException, SAXException {

        // get information
        String publicId = inputSource.getPublicId();
        String systemId = inputSource.getSystemId();
        String encoding = inputSource.getEncoding();

        // create reader
        InputStream stream = null;
        Reader reader = inputSource.getCharacterStream();
        if (reader == null) {
            stream = inputSource.getByteStream();
            if (stream == null) {
                // REVISIT: open system identifier
                stream = new FileInputStream(systemId);
            }
                
            // perform auto-detect of encoding
            if (encoding == null) {
                // read first four bytes and determine encoding
                final byte[] b4 = new byte[4];
                int count = stream.read(b4, 0, 4);
                encoding = getJavaEncodingName(b4, count);

                // push back the characters we read
                PushbackInputStream pbstream = new PushbackInputStream(stream, 4);
                pbstream.unread(b4, 0, count);
                stream = pbstream;
            }

            // create reader from input stream
            // REVISIT: We can use customized readers here. -Ac
            reader = new InputStreamReader(stream, encoding);

            // REVISIT: Activate this reader once I've updated the
            //          entity scanner. -Ac
            //reader = new OneCharReader(reader);
        }

        // REVISIT: This goes away once I've updated the entity
        //          scanner to buffer from a standard java.io.Reader
        //          object. -Ac
        reader = new PushbackReader(reader, 32);

        // push entity on stack
        fCurrentEntity = new ScannedEntity(name, publicId, systemId, 
                                           stream, reader, encoding);
        fEntityStack.push(fCurrentEntity);

        // call handler
        if (fEntityHandler != null) {
            String ianaEncoding = EncodingMap.getJava2IANAMapping(encoding);
            fEntityHandler.startEntity(name, publicId, systemId, ianaEncoding);
        }

    } // startEntity(String,InputSource)

    /**
     * Ends an entity.
     */
    protected void endEntity() throws IOException, SAXException {

        // pop stack
        Entity entity = (Entity)fEntityStack.pop();

        // call handler
        if (fEntityHandler != null) {
            fEntityHandler.endEntity(entity.name);
        }

    } // endEntity(String)

    /**
     * Expands a system id and returns the system id as a URI, if
     * it can be expanded. A return value of null means that the
     * identifier is already expanded. An exception thrown
     * indicates a failure to expand the id.
     *
     * @param systemId The systemId to be expanded.
     *
     * @return Returns the URI string representing the expanded system
     *         identifier. A null value indicates that the given
     *         system identifier is already expanded.
     *
     */
    protected String expandSystemId(String systemId) {
        return expandSystemId(systemId, null);
    } // expandSystemId(String):String

    /**
     * Expands a system id and returns the system id as a URI, if
     * it can be expanded. A return value of null means that the
     * identifier is already expanded. An exception thrown
     * indicates a failure to expand the id.
     *
     * @param systemId The systemId to be expanded.
     *
     * @return Returns the URI string representing the expanded system
     *         identifier. A null value indicates that the given
     *         system identifier is already expanded.
     *
     */
    protected String expandSystemId(String systemId, 
                                    String baseSystemId) {

        // check for bad parameters id
        if (systemId == null || systemId.length() == 0) {
            return systemId;
        }

        // if id already expanded, return
        try {
            URI uri = new URI(systemId);
            if (uri != null) {
                return systemId;
            }
        }
        catch (URI.MalformedURIException e) {
            // continue on...
        }

        // normalize id
        String id = fixURI(systemId);

        // normalize base
        URI base = null;
        URI uri = null;
        try {
            if (baseSystemId == null) {
                String dir;
                try {
                    dir = fixURI(System.getProperty("user.dir"));
                }
                catch (SecurityException se) {
                    dir = "";
                }
                if (!dir.endsWith("/")) {
                    dir = dir + "/";
                }
                base = new URI("file", "", dir, null, null);
            }
            else {
                base = new URI(baseSystemId);
            }

            // expand id
            uri = new URI(base, id);
        }
        catch (Exception e) {
            // let it go through
        }
        if (uri == null) {
            return systemId;
        }
        return uri.toString();

    } // expandSystemId(String,String):String

    //
    // Private methods
    //

    /**
     * Returns the Java encoding name that is auto-detected from
     * the bytes specified.
     *
     * @param b4    The first four bytes of the input.
     * @param count The number of bytes actually read.
     *
     * @returns The Java encoding name.
     */
    private static String getJavaEncodingName(byte[] b4, int count) {

        if (count < 2) {
            return "UTF8";
        }

        // UTF-16, with BOM
        byte b0 = b4[0];
        byte b1 = b4[1];
        if (b0 == 0xFE && b1 == 0xFF) {
            // UTF-16, big-endian
            return "UnicodeBig";
        }
        if (b0 == 0xFF && b1 == 0xFE) {
            // UTF-16, little-endian
            return "UnicodeLittle";
        }

        if (count < 4) {
            return "UTF8";
        }

        // other encodings
        byte b2 = b4[2];
        byte b3 = b4[3];
        if (b0 == 0x00 && b1 == 0x00 && b2 == 0x00 && b3 == 0x3C) {
            // UCS-4, big endian (1234)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b0 == 0x3C && b1 == 0x00 && b2 == 0x00 && b3 == 0x00) {
            // UCS-4, little endian (4321)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b0 == 0x00 && b1 == 0x00 && b2 == 0x3C && b3 == 0x00) {
            // UCS-4, unusual octet order (2143)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b0 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x00) {
            // UCS-4, unusual octect order (3412)
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b1 == 0x00 && b1 == 0x3C && b2 == 0x00 && b3 == 0x3F) {
            // UTF-16, big-endian, no BOM
            // REVISIT: What should this be?
            return "Unicode";
        }
        if (b1 == 0x3C && b1 == 0x00 && b2 == 0x3F && b3 == 0x00) {
            // UTF-16, little-endian, no BOM
            return "UnicodeLittle";
        }
        if (b1 == 0x4C && b1 == 0x6F && b2 == 0xA7 && b3 == 0x94) {
            // EBCDIC
            return "DBCS_EBCDIC";
        }

        // default encoding
        return "UTF8";

    } // getJavaEncodingName(byte[],int):String

    /**
     * Fixes a platform dependent filename to standard URI form.
     *
     * @param str The string to fix.
     *
     * @return Returns the fixed URI string.
     */
    private static String fixURI(String str) {

        // handle platform dependent strings
        str = str.replace(java.io.File.separatorChar, '/');

        // Windows fix
        if (str.length() >= 2) {
            char ch1 = str.charAt(1);
            if (ch1 == ':') {
                char ch0 = Character.toUpperCase(str.charAt(0));
                if (ch0 >= 'A' && ch0 <= 'Z') {
                    str = "/" + str;
                }
            }
        }

        // done
        return str;

    } // fixURI(String):String

    //
    // Classes
    //

    /**
     * Entity information.
     *
     * @author Andy Clark, IBM
     */
    protected static abstract class Entity {

        //
        // Data
        //

        /** Entity name. */
        public String name;

        //
        // Constructors
        //

        /** Constructs an entity. */
        public Entity(String name) {
            this.name = name;
        } // <init>(String)

        //
        // Public methods
        //

        /** Returns true if this is an external entity. */
        public abstract boolean isExternal();

    } // class Entity

    /**
     * Internal entity.
     *
     * @author Andy Clark, IBM
     */
    protected static class InternalEntity
        extends Entity {

        //
        // Data
        //

        /** Text value of entity. */
        public String text;

        //
        // Constructors
        //

        /** Constructs an internal entity. */
        public InternalEntity(String name, String text) {
            super(name);
            this.text = text;
        } // <init>(String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return false;
        } // isExternal():boolean

    } // class InternalEntity

    /**
     * External entity.
     *
     * @author Andy Clark, IBM
     */
    protected static class ExternalEntity 
        extends Entity {
        
        //
        // Data
        //
    
        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Base system identifier. */
        public String baseSystemId;

        //
        // Constructors
        //

        /** Constructs an internal entity. */
        public ExternalEntity(String name, String publicId, String systemId,
                              String baseSystemId) {
            super(name);
            this.publicId = publicId;
            this.systemId = systemId;
            this.baseSystemId = baseSystemId;
        } // <init>(String,String,String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return true;
        } // isExternal():boolean

    } // class ExternalEntity

    /**
     * Entity state.
     *
     * @author Andy Clark, IBM
     */
    protected class ScannedEntity 
        extends Entity {

        //
        // Data
        //

        // i/o

        /** Input stream. */
        public InputStream stream;

        /** Reader. */
        public Reader reader;

        // locator information

        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Line number. */
        public int lineNumber;

        /** Column number. */
        public int columnNumber;

        // encoding

        /** Auto-detected ncoding. */
        public String encoding;

        // buffer

        /** Character buffer. */
        public char[] ch = new char[fBufferSize];

        /** Offset. */
        public int offset;

        /** Length. */
        public int length;

        //
        // Constructors
        //

        /** Constructs a scanned entity. */
        public ScannedEntity(String name, String publicId, String systemId,
                             InputStream stream, Reader reader, 
                             String encoding) {
            super(name);
            this.publicId = publicId;
            this.systemId = systemId;
            this.stream = stream;
            this.reader = reader;
            this.encoding = encoding;
        } // <init>(Reader,String,String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return systemId != null;
        } // isExternal():boolean

    } // class ScannedEntity

    /**
     * Implements the entity scanner methods.
     *
     * @author Andy Clark, IBM
     */
    private class EntityScanner
        extends XMLEntityScanner {
    
        //
        // Constructors
        //
    
        /** Default constructor. */
        public EntityScanner() {
        }
    
        //
        // XMLEntityScanner methods
        //
    
        public void setEncoding(String encoding) throws IOException {
            if (fCurrentEntity.stream != null) {
                OneCharReader ocreader = (OneCharReader)fCurrentEntity.reader;
                fCurrentEntity.reader = ocreader.getReader();
            }
        } // setEncoding(String)

        /**
         * peekChar
         * 
         * @return 
         */
        public int peekChar() throws IOException {
            if (DEBUG) System.out.println("#peekChar()");
            return peek(); 
        } // peekChar():int
    
        /**
         * scanChar
         * 
         * @return 
         */
        public int scanChar() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanChar()");
            int c = read();
            if (c == -1) {
                endEntity();
            }
            return c;
        } // scanChar():int
    
        /**
         * scanNmtoken
         * 
         * @return 
         */
        public String scanNmtoken() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanNmtoken()");
    
            fCurrentEntity.length = 0;
            boolean nmtoken = false;
            while (XMLChar.isName(peek())) {
                nmtoken = true;
                fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
            }
    
            String symbol = null;
            if (nmtoken) {
                symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, fCurrentEntity.length);
            }
            return symbol;
    
        } // scanNmtoken
    
        /**
         * scanName
         * 
         * @return 
         */
        public String scanName() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanName()");
    
            fCurrentEntity.length = 0;
            boolean name = false;
            if (XMLChar.isNameStart(peek())) {
                name = true;
                fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
                while (XMLChar.isName(peek())) {
                    fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
                }
            }
    
            String symbol = null;
            if (name) {
                symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, fCurrentEntity.length);
            }
            return symbol;
    
        } // scanName
    
        /**
         * scanQName
         * 
         * @param qname 
         */
        public boolean scanQName(QName qname) throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanQName()");
    
            String prefix = null;
            String localpart = null;
            String rawname = null;
    
            fCurrentEntity.length = 0;
            int colons = -1;
            int index = 0;
            if (XMLChar.isNameStart(peek())) {
                colons = 0;
                fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
                int c = -1;
                while (XMLChar.isName(c = peek())) {
                    if (c == ':') {
                        colons++;
                        if (colons == 1) {
                            index = fCurrentEntity.length + 1;
                            prefix = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, fCurrentEntity.length);
                        }
                    }
                    fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
                }
                localpart = fSymbolTable.addSymbol(fCurrentEntity.ch, index, fCurrentEntity.length - index);
                rawname = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, fCurrentEntity.length);
            }
    
            if (colons >= 0 && colons < 2) {
                qname.setValues(prefix, localpart, rawname, null);
                return true;
            }
    
            return false;
    
        } // scanQName
    
        /**
         * scanContent
         * 
         * @param content 
         */
        public int scanContent(XMLString content) 
            throws IOException, SAXException {
    
            fCurrentEntity.length = 0;
            while (peek() != '<' && peek() != '&') {
                fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
                if (fCurrentEntity.length == fCurrentEntity.ch.length) {
                    break;
                }
            }
            content.setValues(fCurrentEntity.ch, 0, fCurrentEntity.length);
    
            return peek();
    
        } // scanContent
    
        /**
         * scanAttContent
         * 
         * @param quote
         * @param content 
         */
        public int scanAttContent(int quote, XMLString content)
            throws IOException, SAXException {
    
            fCurrentEntity.length = 0;
            while (peek() != quote) {
                fCurrentEntity.ch[fCurrentEntity.length++] = (char)read();
                if (fCurrentEntity.length == fCurrentEntity.ch.length) {
                    break;
                }
            }
            content.setValues(fCurrentEntity.ch, 0, fCurrentEntity.length);
    
            return peek();
    
        } // scanAttContent
    
        /**
         * scanData
         *
         * @param delimiter
         * @param data
         */
        public boolean scanData(String delimiter, XMLString data)
            throws IOException, SAXException {
            // TODO
            throw new RuntimeException("not implemented");
        } // scanData(String,XMLString)
    
        /**
         * skipChar
         *
         * @param c
         */
        public boolean skipChar(int c) throws IOException, SAXException {
            int pc = read();
            if (pc != c) {
                unread(pc);
            }
            return pc == c;
        }
    
        /**
         * skipSpaces
         */
        public boolean skipSpaces() throws IOException, SAXException {
            if (DEBUG) System.out.println("#skipSpaces()");
    
            boolean spaces = false;
            while (XMLChar.isSpace(peek())) {
                spaces = true;
                read();
            }
    
            return spaces;
    
        } // skipSpaces
    
        /**
         * skipString
         *
         * @param s
         */
        public boolean skipString(String s) throws IOException, SAXException {
            if (DEBUG) System.out.println("#skipString(\""+s+"\")");
    
            int length = s.length();
            for (int i = 0; i < length; i++) {
                int c = read();
                if (c != s.charAt(i)) {
                    unread(c);
                    if (i > 0) {
                        char[] ch = new char[i];
                        s.getChars(0, i, ch, 0);
                        unread(ch, 0, ch.length);
                    }
                    return false;
                }
            }
    
            return true;
    
        } // skipString
    
        //
        // Locator methods
        //
    
        /**
         * getPublicId
         * 
         * @return 
         */
        public String getPublicId() {
            return fCurrentEntity.publicId;
        } // getPublicId():String
    
        /**
         * getSystemId
         * 
         * @return 
         */
        public String getSystemId() {
            return fCurrentEntity.systemId;
        } // getSystemId():String
    
        /**
         * getLineNumber
         * 
         * @return 
         */
        public int getLineNumber() {
            return fCurrentEntity.lineNumber;
        } // getLineNumber():int
    
        /**
         * getColumnNumber
         * 
         * @return 
         */
        public int getColumnNumber() {
            return fCurrentEntity.columnNumber;
        } // getColumnNumber():int
    
        //
        // Private methods
        //
    
        /** Peeks the next character. */
        private final int peek() throws IOException {
            int c = fCurrentEntity.reader.read();
            if (c == -1) {
                throw new EOFException();
            }
            if (DEBUG) System.out.println("?"+(char)c);
            ((PushbackReader)fCurrentEntity.reader).unread(c);
            return c;
        }
    
        /** Reads the next character. */
        private int read() throws IOException {
            int c = fCurrentEntity.reader.read();
            if (c == -1) {
                throw new EOFException();
            }
            if (DEBUG) System.out.println("+"+(char)c);
            return c;
        }
    
        private void unread(int c) throws IOException {
            if (DEBUG) System.out.println("-"+(char)c);
            ((PushbackReader)fCurrentEntity.reader).unread(c);
        }
    
        private void unread(char[] ch, int offset, int length) throws IOException {
            if (DEBUG) System.out.println("-"+new String(ch, offset, length));
            ((PushbackReader)fCurrentEntity.reader).unread(ch, offset, length);
        }
    
    } // class EntityScanner

    /**
     * A reader that reads only one character at a time. This is
     * needed for those times when we've auto-detected the encoding
     * from an input stream and need to swap out the reader once
     * the xmlDecl/textDecl has been read and processed. If we
     * read too far, then we could erroneously convert bytes from
     * the input stream to the wrong character code point.
     *
     * @author Andy Clark, IBM
     */
    protected class OneCharReader
        extends FilterReader {

        //
        // Data
        //

        /** True if we've seen the end of the first markup. */
        private boolean seenEndOfMarkup;

        //
        // Constructors
        //

        /** Constructs this reader from another reader. */
        public OneCharReader(Reader reader) {
            super(reader);
        }

        //
        // Public methods
        //

        /** Returns the reader that is being wrapped. */
        public Reader getReader() {
            return in;
        } // getReader():Reader

        //
        // Reader methods
        //

        /** Returns a single character. */
        public int read() throws IOException {

            // swap out this inefficient reader because we've
            // already passed the first piece of markup and
            // the encoding was not set
            if (seenEndOfMarkup) {
                fCurrentEntity.reader = getReader();
                return fCurrentEntity.reader.read();
            }

            // read character and look for end of markup
            int c = in.read();
            seenEndOfMarkup = c == '>';
            return c;

        } // read():int

        /** 
         * Reads as many characters as possible which, in this case,
         * is only a single character.
         */
        public int read(char[] ch, int offset, int length)
            throws IOException {

            // handle end of file
            int c = read();
            if (c == -1) {
                return 0;
            }

            // return the 1 character
            ch[offset] = (char)c;
            return 1;

        } // read(char[],int,int):int

    } // class OneCharReader

} // class XMLEntityManager
