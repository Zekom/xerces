/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999,2000 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xerces" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, International
 * Business Machines, Inc., http://www.apache.org.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 */

package org.apache.xerces.impl;

import java.io.EOFException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.PushbackReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.Hashtable;
import java.util.Stack;

import org.apache.xerces.util.SymbolTable;
import org.apache.xerces.util.XMLChar;

import org.apache.xerces.xni.QName;
import org.apache.xerces.xni.XMLComponent;
import org.apache.xerces.xni.XMLComponentManager;
import org.apache.xerces.xni.XMLEntityHandler;
import org.apache.xerces.xni.XMLString;

import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

/**
 * The entity manager handles the registration of general and parameter
 * entities; resolves entities; and starts entities. The entity manager
 * is a central component in a standard parser configuration and this
 * class works directly with the entity scanner to manage the underlying
 * xni.
 * <p>
 * This component requires the following features and properties from the
 * component manager that uses it:
 * <ul>
 *  <li>http://apache.org/xml/properties/internal/entity-resolver</li>
 *  <li>http://apache.org/xml/properties/internal/symbol-table</li>
 * </ul>
 *
 *
 * @author Stubs generated by DesignDoc on Mon Sep 18 18:23:16 PDT 2000
 * @author Andy Clark, IBM
 *
 * @version $Id$
 */
public class XMLEntityManager
    implements XMLComponent {

    //
    // Constants
    //

    // xerces features

    /** Xerces feature prefix. */
    //protected static final String XERCES_FEATURE_PREFIX = "http://apache.org/xml/features/";

    // xerces properties

    /** Xerces property prefix. */
    protected static final String XERCES_PROPERTY_PREFIX = "http://apache.org/xml/properties/";

    /** Entity resolver property id. */
    protected static final String ENTITY_RESOLVER_PROPERTY = "internal/entity-resolver";

    /** Symbol table property id. */
    protected static final String SYMBOL_TABLE_PROPERTY = "internal/symbol-table";

    // debugging

    /** Debugging. */
    private static final boolean DEBUG = false;

    //
    // Data
    //

    // properties

    /** Entity resolver. */
    protected EntityResolver fEntityResolver;

    /** Symbol table. */
    protected SymbolTable fSymbolTable;

    // handlers

    /** Entity handler. */
    protected XMLEntityHandler fEntityHandler;

    // scanner

    /** Entity scanner. */
    protected XMLEntityScanner fEntityScanner;

    /** Entities. */
    protected Hashtable fEntities = new Hashtable();

    /** Entity stack. */
    protected Stack fEntityStack = new Stack();

    /** Current entity. */
    protected ScannedEntity fCurrentEntity;

    // private

    /** Reader. */
    private PushbackReader fReader;

    /** Character buffer. */
    private char[] fBuffer = new char[1024];

    /** Buffer length. */
    private int fLength;

    //
    // Constructors
    //

    /** Default constructor. */
    public XMLEntityManager() {
        fEntityScanner = new EntityScanner();
    }

    //
    // Public methods
    //

    /**
     * setEntityHandler
     *
     * @param entityHandler The new entity handler.
     */
    public void setEntityHandler(XMLEntityHandler entityHandler) {
        fEntityHandler = entityHandler;
    }

    /**
     * addExternalEntity
     * 
     * @param name 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     */
    public void addExternalEntity(String name, String publicId, String systemId, String baseSystemId) {
        name = fSymbolTable.addSymbol(name);
        Entity entity = new ExternalEntity(name, publicId, systemId, baseSystemId);
        fEntities.put(name, entity);
    } // addExternalEntity(String,String,String,String)

    /**
     * addInternalEntity
     * 
     * @param name 
     * @param text 
     */
    public void addInternalEntity(String name, String text) {
        name = fSymbolTable.addSymbol(name);
        Entity entity = new InternalEntity(name, text);
        fEntities.put(name, entity);
    } // addInternalEntity(String,String)

    /**
     * resolveEntity
     * 
     * @param publicId 
     * @param systemId 
     * @param baseSystemId 
     * 
     * @return 
     */
    public InputSource resolveEntity(String publicId, String systemId, String baseSystemId)
        throws IOException, SAXException {
        throw new RuntimeException("XMLEntityManager#resolveEntity(String,String,String) not implemented");
    } // resolveEntity

    /**
     * startEntity
     * 
     * @param entityName 
     * @param parameter 
     */
    public void startEntity(String entityName) 
        throws IOException, SAXException {

        // resolve external entity
        Entity entity = (Entity)fEntities.get(entityName);
        InputSource inputSource = null;
        if (entity.isExternal()) {
            ExternalEntity externalEntity = (ExternalEntity)entity;
            String publicId = externalEntity.publicId;
            String systemId = externalEntity.systemId;
            String baseSystemId = externalEntity.baseSystemId;
            inputSource = resolveEntity(publicId, systemId, baseSystemId);
        }

        // wrap internal entity
        else {
            InternalEntity internalEntity = (InternalEntity)entity;
            Reader reader = new StringReader(internalEntity.text);
            inputSource = new InputSource(reader);
        }

        // start the entity
        startEntity(entityName, inputSource);

    } // startEntity(String)

    /**
     * startDocumentEntity
     * 
     * @param inputSource 
     */
    public void startDocumentEntity(InputSource inputSource) 
        throws IOException, SAXException {
        startEntity("[xml]", inputSource);
    } // startDocumentEntity(InputSource)

    /**
     * startDTDEntity
     *
     * @param inputSource
     */
    public void startDTDEntity(InputSource inputSource)
        throws IOException, SAXException {
        startEntity("[dtd]", inputSource);
    } // startDTDEntity(InputSource)

    /**
     * getEntityScanner
     * 
     * @return 
     */
    public XMLEntityScanner getEntityScanner() {
        return fEntityScanner;
    } // getEntityScanner

    //
    // XMLComponent methods
    //

    /**
     * reset
     * 
     * @param configurationManager 
     */
    public void reset(XMLComponentManager componentManager)
        throws SAXException {

        // Xerces properties
        final String ENTITY_RESOLVER = XERCES_PROPERTY_PREFIX + ENTITY_RESOLVER_PROPERTY;
        fEntityResolver = (EntityResolver)componentManager.getProperty(ENTITY_RESOLVER);
        final String SYMBOL_TABLE = XERCES_PROPERTY_PREFIX + SYMBOL_TABLE_PROPERTY;
        fSymbolTable = (SymbolTable)componentManager.getProperty(SYMBOL_TABLE);

        // initialize state
        fEntities.clear();
        fEntityStack.removeAllElements();

        // add default entities
        addInternalEntity("lt", "<");
        addInternalEntity("gt", ">");
        addInternalEntity("amp", "&");
        addInternalEntity("apos", "'");
        addInternalEntity("quot", "\"");

        // initialize scanner info
        fReader = null;

    } // reset(XMLComponentManager)

    /**
     * setFeature
     * 
     * @param featureId 
     * @param state 
     */
    public void setFeature(String featureId, boolean state)
        throws SAXNotRecognizedException, SAXNotSupportedException {
    } // setFeature(String,boolean)

    /**
     * setProperty
     * 
     * @param propertyId 
     * @param value 
     */
    public void setProperty(String propertyId, Object value)
        throws SAXNotRecognizedException, SAXNotSupportedException {

        // Xerces properties
        if (propertyId.startsWith(XERCES_PROPERTY_PREFIX)) {
            String property = propertyId.substring(XERCES_PROPERTY_PREFIX.length());
            if (property.equals(ENTITY_RESOLVER_PROPERTY)) {
                fEntityResolver = (EntityResolver)value;
                return;
            }
            if (property.equals(SYMBOL_TABLE_PROPERTY)) {
                fSymbolTable = (SymbolTable)value;
                return;
            }
        }

    } // setProperty(String,Object)

    //
    // Protected methods
    //

    /**
     * Starts an entity. 
     */
    protected void startEntity(String name, InputSource inputSource)
        throws IOException, SAXException {

        // get information
        String publicId = inputSource.getPublicId();
        String systemId = inputSource.getSystemId();
        String encoding = inputSource.getEncoding();

        // create reader
        Reader reader = inputSource.getCharacterStream();
        if (reader == null) {
            InputStream stream = inputSource.getByteStream();
            if (stream == null) {
                // REVISIT: open system identifier
                stream = new FileInputStream(systemId);
            }
            reader = new InputStreamReader(stream);
        }
        fReader = new PushbackReader(reader, 32);

        // push entity on stack
        fCurrentEntity = new ScannedEntity(name, publicId, systemId, reader);
        fEntityStack.push(fCurrentEntity);

        // call handler
        if (fEntityHandler != null) {
            fEntityHandler.startEntity(name, publicId, systemId, encoding);
        }

    } // startEntity(String,InputSource)

    /**
     * Ends an entity.
     */
    protected void endEntity() throws IOException, SAXException {

        // pop stack
        Entity entity = (Entity)fEntityStack.pop();

        // call handler
        if (fEntityHandler != null) {
            fEntityHandler.endEntity(entity.name);
        }

    } // endEntity(String)

    //
    // Classes
    //

    /**
     * Entity information.
     *
     * @author Andy Clark, IBM
     */
    protected static abstract class Entity {

        //
        // Data
        //

        /** Entity name. */
        public String name;

        //
        // Constructors
        //

        /** Constructs an entity. */
        public Entity(String name) {
            this.name = name;
        } // <init>(String)

        //
        // Public methods
        //

        /** Returns true if this is an external entity. */
        public abstract boolean isExternal();

    } // class Entity

    /**
     * Internal entity.
     *
     * @author Andy Clark, IBM
     */
    protected static class InternalEntity
        extends Entity {

        //
        // Data
        //

        /** Text value of entity. */
        public String text;

        //
        // Constructors
        //

        /** Constructs an internal entity. */
        public InternalEntity(String name, String text) {
            super(name);
            this.text = text;
        } // <init>(String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return false;
        } // isExternal():boolean

    } // class InternalEntity

    /**
     * External entity.
     *
     * @author Andy Clark, IBM
     */
    protected static class ExternalEntity 
        extends Entity {
        
        //
        // Data
        //
    
        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Base system identifier. */
        public String baseSystemId;

        //
        // Constructors
        //

        /** Constructs an internal entity. */
        public ExternalEntity(String name, String publicId, String systemId,
                              String baseSystemId) {
            super(name);
            this.publicId = publicId;
            this.systemId = systemId;
            this.baseSystemId = baseSystemId;
        } // <init>(String,String,String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return true;
        } // isExternal():boolean

    } // class ExternalEntity

    /**
     * Entity state.
     *
     * @author Andy Clark, IBM
     */
    protected static class ScannedEntity 
        extends Entity {

        //
        // Data
        //

        // i/o

        /** Reader. */
        public Reader reader;

        // locator information

        /** Public identifier. */
        public String publicId;

        /** System identifier. */
        public String systemId;

        /** Line number. */
        public int lineNumber;

        /** Column number. */
        public int columnNumber;

        // buffer

        /** Character buffer. */
        public char[] ch;

        /** Offset. */
        public int offset;

        /** Length. */
        public int length;

        //
        // Constructors
        //

        /** Constructs a scanned entity. */
        public ScannedEntity(String name, String publicId, String systemId,
                             Reader reader) {
            super(name);
            this.publicId = publicId;
            this.systemId = systemId;
            this.reader = reader;
        } // <init>(Reader,String,String,String)

        //
        // Entity methods
        //

        /** Returns true if this is an external entity. */
        public final boolean isExternal() {
            return systemId != null;
        } // isExternal():boolean

    } // class ScannedEntity

    /**
     * Implements the entity scanner methods.
     *
     * @author Andy Clark, IBM
     */
    private class EntityScanner
        extends XMLEntityScanner {
    
        //
        // Constructors
        //
    
        /** Default constructor. */
        public EntityScanner() {
        }
    
        //
        // XMLEntityScanner methods
        //
    
        /**
         * peekChar
         * 
         * @return 
         */
        public int peekChar() throws IOException {
            if (DEBUG) System.out.println("#peekChar()");
            return peek(); 
        } // peekChar():int
    
        /**
         * scanChar
         * 
         * @return 
         */
        public int scanChar() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanChar()");
            int c = read();
            if (c == -1) {
                endEntity();
            }
            return c;
        } // scanChar():int
    
        /**
         * scanNmtoken
         * 
         * @return 
         */
        public String scanNmtoken() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanNmtoken()");
    
            fLength = 0;
            boolean nmtoken = false;
            while (XMLChar.isName(peek())) {
                nmtoken = true;
                fBuffer[fLength++] = (char)read();
            }
    
            String symbol = null;
            if (nmtoken) {
                symbol = fSymbolTable.addSymbol(fBuffer, 0, fLength);
            }
            return symbol;
    
        } // scanNmtoken
    
        /**
         * scanName
         * 
         * @return 
         */
        public String scanName() throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanName()");
    
            fLength = 0;
            boolean name = false;
            if (XMLChar.isNameStart(peek())) {
                name = true;
                fBuffer[fLength++] = (char)read();
                while (XMLChar.isName(peek())) {
                    fBuffer[fLength++] = (char)read();
                }
            }
    
            String symbol = null;
            if (name) {
                symbol = fSymbolTable.addSymbol(fBuffer, 0, fLength);
            }
            return symbol;
    
        } // scanName
    
        /**
         * scanQName
         * 
         * @param qname 
         */
        public boolean scanQName(QName qname) throws IOException, SAXException {
            if (DEBUG) System.out.println("#scanQName()");
    
            String prefix = null;
            String localpart = null;
            String rawname = null;
    
            fLength = 0;
            int colons = -1;
            int index = 0;
            if (XMLChar.isNameStart(peek())) {
                colons = 0;
                fBuffer[fLength++] = (char)read();
                int c = -1;
                while (XMLChar.isName(c = peek())) {
                    if (c == ':') {
                        colons++;
                        if (colons == 1) {
                            index = fLength + 1;
                            prefix = fSymbolTable.addSymbol(fBuffer, 0, fLength);
                        }
                    }
                    fBuffer[fLength++] = (char)read();
                }
                localpart = fSymbolTable.addSymbol(fBuffer, index, fLength - index);
                rawname = fSymbolTable.addSymbol(fBuffer, 0, fLength);
            }
    
            if (colons >= 0 && colons < 2) {
                qname.setValues(prefix, localpart, rawname, null);
                return true;
            }
    
            return false;
    
        } // scanQName
    
        /**
         * scanContent
         * 
         * @param content 
         */
        public int scanContent(XMLString content) 
            throws IOException, SAXException {
    
            fLength = 0;
            while (peek() != '<' && peek() != '&') {
                fBuffer[fLength++] = (char)read();
                if (fLength == fBuffer.length) {
                    break;
                }
            }
            content.setValues(fBuffer, 0, fLength);
    
            return peek();
    
        } // scanContent
    
        /**
         * scanAttContent
         * 
         * @param quote
         * @param content 
         */
        public int scanAttContent(int quote, XMLString content)
            throws IOException, SAXException {
    
            fLength = 0;
            while (peek() != quote) {
                fBuffer[fLength++] = (char)read();
                if (fLength == fBuffer.length) {
                    break;
                }
            }
            content.setValues(fBuffer, 0, fLength);
    
            return peek();
    
        } // scanAttContent
    
        /**
         * scanData
         *
         * @param delimiter
         * @param data
         */
        public boolean scanData(String delimiter, XMLString data)
            throws IOException, SAXException {
            // TODO
            throw new RuntimeException("not implemented");
        } // scanData(String,XMLString)
    
        /**
         * skipChar
         *
         * @param c
         */
        public boolean skipChar(int c) throws IOException, SAXException {
            int pc = read();
            if (pc != c) {
                unread(pc);
            }
            return pc == c;
        }
    
        /**
         * skipSpaces
         */
        public boolean skipSpaces() throws IOException, SAXException {
            if (DEBUG) System.out.println("#skipSpaces()");
    
            boolean spaces = false;
            while (XMLChar.isSpace(peek())) {
                spaces = true;
                read();
            }
    
            return spaces;
    
        } // skipSpaces
    
        /**
         * skipString
         *
         * @param s
         */
        public boolean skipString(String s) throws IOException, SAXException {
            if (DEBUG) System.out.println("#skipString(\""+s+"\")");
    
            int length = s.length();
            for (int i = 0; i < length; i++) {
                int c = read();
                if (c != s.charAt(i)) {
                    unread(c);
                    if (i > 0) {
                        char[] ch = new char[i];
                        s.getChars(0, i, ch, 0);
                        unread(ch, 0, ch.length);
                    }
                    return false;
                }
            }
    
            return true;
    
        } // skipString
    
        //
        // Locator methods
        //
    
        /**
         * getPublicId
         * 
         * @return 
         */
        public String getPublicId() {
            return fCurrentEntity.publicId;
        } // getPublicId():String
    
        /**
         * getSystemId
         * 
         * @return 
         */
        public String getSystemId() {
            return fCurrentEntity.systemId;
        } // getSystemId():String
    
        /**
         * getLineNumber
         * 
         * @return 
         */
        public int getLineNumber() {
            return fCurrentEntity.lineNumber;
        } // getLineNumber():int
    
        /**
         * getColumnNumber
         * 
         * @return 
         */
        public int getColumnNumber() {
            return fCurrentEntity.columnNumber;
        } // getColumnNumber():int
    
        //
        // Private methods
        //
    
        /** Peeks the next character. */
        private final int peek() throws IOException {
            int c = fReader.read();
            if (c == -1) {
                throw new EOFException();
            }
            if (DEBUG) System.out.println("?"+(char)c);
            fReader.unread(c);
            return c;
        }
    
        /** Reads the next character. */
        private int read() throws IOException {
            int c = fReader.read();
            if (c == -1) {
                throw new EOFException();
            }
            if (DEBUG) System.out.println("+"+(char)c);
            return c;
        }
    
        private void unread(int c) throws IOException {
            if (DEBUG) System.out.println("-"+(char)c);
            fReader.unread(c);
        }
    
        private void unread(char[] ch, int offset, int length) throws IOException {
            if (DEBUG) System.out.println("-"+new String(ch, offset, length));
            fReader.unread(ch, offset, length);
        }
    
    } // class EntityScanner

} // class XMLEntityManager
